/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.15u-20021007-2154
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */


#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    inline SwigValueWrapper() : tt(0) { }
    inline ~SwigValueWrapper() { if (tt) delete tt; } 
    inline SwigValueWrapper& operator=(const T& t) { tt = new T(t); return *this; }
    inline operator T&() const { return *tt; }
    inline T *operator&() { return tt; }
};                                                    
#endif

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;	
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;	
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/*
 * php4.swg
 *
 * PHP4 runtime library
 *
 */

#ifdef __cplusplus
extern "C" {
#endif
#include "zend.h"
#include "zend_API.h"
#include "php.h"

// These TSRMLS_ stuff should already be defined now, but with older php under
// redhat are not...
#ifndef TSRMLS_D
#define TSRMLS_D
#endif
#ifndef TSRMLS_DC
#define TSRMLS_DC
#endif
#ifndef TSRMLS_C
#define TSRMLS_C
#endif
#ifndef TSRMLS_CC
#define TSRMLS_CC
#endif

#ifdef __cplusplus
}
#endif

// used to wrap returned objects in so we know whether they are newobject
// and need freeing, or not
typedef struct _swig_object_wrapper {
  void * ptr;
  int newobject;
} swig_object_wrapper;

// local scope self_constructors are set to 1 inside function wrappers
// which are also class constructors, so that the php4.swg output typemaps
// know whether or not to wrap returned objects in this_ptr or a new object
int self_constructor=0;

// empty zend destructor for types without one
static ZEND_RSRC_DTOR_FUNC(SWIG_landfill) {};

// This one makes old swig style string pointers but the php module doesn't
// use these any more.  This is just left here for old times sake and may go
SWIGRUNTIME(void)
SWIG_MakePtr(char *c, void *ptr, swig_type_info *ty) {
  static char hex[17] = "0123456789abcdef";
  unsigned long p, s;
  char data[32], *r;

  r = data;
  p = (unsigned long) ptr;
  if (p > 0) {
    while (p > 0) {
      s = p & 0xf;
      *(r++) = hex[s];
      p = p >> 4;
    }
    *r = '_';
    while (r >= data) {
      *(c++) = *(r--);
    }
    strcpy (c, ty->name);
  } else {
    strcpy (c, "NULL");
  }
}

SWIGRUNTIME(void)
SWIG_SetPointerChar(char **c, void *ptr, swig_type_info *type) {
   char data[512];

   SWIG_MakePtr(data, ptr, type);
   *c = estrdup(data);
}

#define SWIG_SetPointerZval(a,b,c,d) SWIG_ZTS_SetPointerZval(a,b,c,d, SWIG_module_entry TSRMLS_CC)

SWIGRUNTIME(void)
SWIG_ZTS_SetPointerZval(zval *z, void *ptr, swig_type_info *type, int newobject, zend_module_entry* module_entry TSRMLS_DC) {
  swig_object_wrapper *value=NULL;
  // No need to call SWIG_MakePtr here!
  if (type->clientdata) {
    if (! (*(int *)(type->clientdata))) zend_error(E_ERROR, "Type: %s failed to register with zend",type->name);
    value=(swig_object_wrapper *)emalloc(sizeof(swig_object_wrapper));
    value->ptr=ptr;
    value->newobject=newobject;
    ZEND_REGISTER_RESOURCE(z, value, *(int *)(type->clientdata));
    return;
  } else { // have to deal with old fashioned string pointer?
           // but this should not get this far
    zend_error(E_ERROR, "Type: %s not registered with zend",type->name);
  }
}

// This old-style routine converts an old string-pointer c into a real pointer
// ptr calling making appropriate casting functions according to ty
// We don't use this any more
SWIGRUNTIME(int)
_SWIG_ConvertPtr(char *c, void **ptr, swig_type_info *ty) {
   register int d;
   unsigned long p;
   swig_type_info *tc;

   if(c == NULL) {
   	*ptr = 0;
	return 0;
   }

   p = 0;
   if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
	return 0;
    } else {
	goto type_error;
    }
  }

    c++;
    /* Extract hex value from pointer */
    while ((d = *c)) {
      if ((d >= '0') && (d <= '9'))
        p = (p << 4) + (d - '0');
      else if ((d >= 'a') && (d <= 'f'))
        p = (p << 4) + (d - ('a'-10));
      else
        break;
      c++;
    }
    *ptr = (void *) p;
	
    if(ty) {
	tc = SWIG_TypeCheck(c,ty);
	if(!tc) goto type_error;
	*ptr = SWIG_TypeCast(tc, (void*)p);
    }
    return 0;

type_error:

    return -1;
}

// This is a new pointer conversion routine
// Taking the native pointer p (which would have been converted from the old
// string pointer) and it's php type id, and it's type name (which also would
// have come from the old string pointer) it converts it to ptr calling 
// appropriate casting functions according to ty
// Sadly PHP has no API to find a type name from a type id, only from an instance
// of a resource of the type id, so we have to pass type_name as well.
// The two functions which might call this are:
// SWIG_ZTS_ConvertResourcePtr which gets the type name from the resource
// and the registered zend destructors for which we have one per type each
// with the type name hard wired in.
SWIGRUNTIME(int)
SWIG_ZTS_ConvertResourceData(void * p, int type, const char *type_name, void **ptr, swig_type_info *ty TSRMLS_DC) {
  swig_type_info *tc;

  if (ty) {
    if (! type_name) {  
      // can't convert p to ptr type ty if we don't know what type p is
      return -1;
    } else {
      // convert and cast p from type_name to ptr as ty
      // Need to sort out const-ness, can SWIG_TypeCast really not take a const?
      tc = SWIG_TypeCheck((char *)type_name,ty);
      if (!tc) return -1;
      *ptr = SWIG_TypeCast(tc, (void*)p);
    }
  } else {
    // They don't care about the target type, so just pass on the pointer!
    *ptr = (void *) p;
  }
  return 0;
}

// This function fills ptr with a pointer of type ty by extracting the pointer
// and type info from the resource in z.  z must be a resource
// It uses SWIG_ZTS_ConvertResourceData to do the real work.
SWIGRUNTIME(int)
SWIG_ZTS_ConvertResourcePtr(zval *z, void **ptr, swig_type_info *ty TSRMLS_DC) {
  swig_object_wrapper *value;
  void *p;
  int type;
  char *type_name;

  value = (swig_object_wrapper *) zend_list_find(z->value.lval,&type);
  p = value->ptr;
  if (type==-1) return -1;

  type_name=zend_rsrc_list_get_rsrc_type(z->value.lval);

  return SWIG_ZTS_ConvertResourceData(p,type,type_name,ptr,ty TSRMLS_CC);
}

// But in fact SWIG_ConvertPtr is the native interface for getting typed
// pointer values out of zvals.  We need the TSRMLS_ macros for when we
// make PHP type calls later as we handle php resources
#define SWIG_ConvertPtr(a,b,c) SWIG_ZTS_ConvertPtr(a,b,c TSRMLS_CC)

// We allow passing of a STRING or RESOURCE pointing to the object
// or an OBJECT whose _cPtr is a string or resource pointing to the object
// STRING pointers are very depracated
SWIGRUNTIME(int)
SWIG_ZTS_ConvertPtr(zval *z, void **ptr, swig_type_info *ty TSRMLS_DC) {
   char *c;
   zval *val;
   
   if(z == NULL) {
	*ptr = 0;
	return 0;
   }

   if (z->type==IS_OBJECT) {
     zval ** _cPtr;
     if (zend_hash_find(HASH_OF(z),"_cPtr",sizeof("_cPtr"),(void**)&_cPtr)==SUCCESS) {
       // Don't co-erce to string if it isn't
       if ((*_cPtr)->type==IS_STRING) c = Z_STRVAL_PP(_cPtr);
       else if ((*_cPtr)->type==IS_RESOURCE) {
         return SWIG_ZTS_ConvertResourcePtr(*_cPtr,ptr,ty TSRMLS_CC);
       } else goto type_error; // _cPtr was not string or resource property
     } else goto type_error; // can't find property _cPtr
   } else if (z->type==IS_RESOURCE) {
     return SWIG_ZTS_ConvertResourcePtr(z,ptr,ty TSRMLS_CC);
   } else if (z->type==IS_STRING) {
     c = Z_STRVAL_P(z); 
     return _SWIG_ConvertPtr(c,ptr,ty);
   } else goto type_error;

type_error:

    return -1;
}


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_SWLocale swig_types[0] 
#define  SWIGTYPE_p_SWMgr swig_types[1] 
#define  SWIGTYPE_p_SWCom swig_types[2] 
#define  SWIGTYPE_p_RawLD4 swig_types[3] 
#define  SWIGTYPE_p_ListKey swig_types[4] 
#define  SWIGTYPE_p_SWKey swig_types[5] 
#define  SWIGTYPE_p_ConfigEntMap swig_types[6] 
#define  SWIGTYPE_p_p_char swig_types[7] 
#define  SWIGTYPE_p_RawLD swig_types[8] 
#define  SWIGTYPE_p_TreeKey swig_types[9] 
#define  SWIGTYPE_p_bool swig_types[10] 
#define  SWIGTYPE_p_void swig_types[11] 
#define  SWIGTYPE_p_SWFilterMgr swig_types[12] 
#define  SWIGTYPE_p_SWLD swig_types[13] 
#define  SWIGTYPE_p_SWTextDirection swig_types[14] 
#define  SWIGTYPE_p_RawText swig_types[15] 
#define  SWIGTYPE_p_f_char_p_void__void swig_types[16] 
#define  SWIGTYPE_p_VerseKey swig_types[17] 
#define  SWIGTYPE_p_ModMap swig_types[18] 
#define  SWIGTYPE_p_string swig_types[19] 
#define  SWIGTYPE_p_SectionMap swig_types[20] 
#define  SWIGTYPE_p_SWDisplay swig_types[21] 
#define  SWIGTYPE_p_AttributeTypeList swig_types[22] 
#define  SWIGTYPE_p_SWText swig_types[23] 
#define  SWIGTYPE_p_SWCompress swig_types[24] 
#define  SWIGTYPE_p_LZSSCompress swig_types[25] 
#define  SWIGTYPE_p_ZipCompress swig_types[26] 
#define  SWIGTYPE_p_SW_POSITION swig_types[27] 
#define  SWIGTYPE_p_SWModule swig_types[28] 
#define  SWIGTYPE_p_zLD swig_types[29] 
#define  SWIGTYPE_p_SWGenBook swig_types[30] 
#define  SWIGTYPE_p_RawGenBook swig_types[31] 
#define  SWIGTYPE_p_SWConfig swig_types[32] 
#define  SWIGTYPE_p_LocaleMgr swig_types[33] 
#define  SWIGTYPE_p_int swig_types[34] 
#define  SWIGTYPE_p_SWTextMarkup swig_types[35] 
#define  SWIGTYPE_p_OptionsList swig_types[36] 
#define  SWIGTYPE_p_listTstring_t swig_types[37] 
#define  SWIGTYPE_p_zText swig_types[38] 
#define  SWIGTYPE_p_SWTextEncoding swig_types[39] 
#define  SWIGTYPE_p_unsigned_long swig_types[40] 
static swig_type_info *swig_types[42];

/* -------- TYPES TABLE (END) -------- */

/* header section */
/*
  +----------------------------------------------------------------------+
  | PHP version 4.0                                                      |
  +----------------------------------------------------------------------+
  | Copyright (c) 1997, 1998, 1999, 2000, 2001 The PHP Group             |
  +----------------------------------------------------------------------+
  | This source file is subject to version 2.02 of the PHP license,      |
  | that is bundled with this package in the file LICENSE, and is        |
  | available at through the world-wide-web at                           |
  | http://www.php.net/license/2_02.txt.                                 |
  | If you did not receive a copy of the PHP license and are unable to   |
  | obtain it through the world-wide-web, please send a note to          |
  | license@php.net so we can mail you a copy immediately.               |
  +----------------------------------------------------------------------+
  | Authors:                                                             |
  |                                                                      |
  +----------------------------------------------------------------------+
 */
#define SWIG_init	initSword

#define SWIG_name	"Sword"
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif
#include "php.h"
#include "php_ini.h"
#include "ext/standard/info.h"
#include "php_Sword.h"
#ifdef __cplusplus
}
#endif


#undef bool
#undef assert
#undef LOCAL
#undef list


 #include <stdio.h>
 #include <string>
 #include <map>
 #include <defs.h>
 #include <multimapwdef.h>

 #include "swconfig.h"
using namespace sword;


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


// We should make use of "code" if we can
#define SWIG_exception(code, msg) { zend_error(E_ERROR, msg); }


#include <string>


#include <vector>
#include <algorithm>
#include <stdexcept>

void SWConfig_set(SWConfig *self,char const *group,char const *entry,char const *value){
	self->Sections[group][entry] = value;
  }
char const *SWConfig_get(SWConfig *self,char const *group,char const *entry){
	return self->Sections[group][entry].c_str();
  }
static int _wrap_propset_SWConfig(zend_property_reference *property_reference, pval *value);
static int _propset_SWConfig(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWConfig(zend_property_reference *property_reference);
static int _propget_SWConfig(zend_property_reference *property_reference, pval *value);

#include <swmgr.h>

SWModule *SWMgr_module(SWMgr *self,char const *modulename){
  	return self->Modules[modulename];
  }
static int _wrap_propset_SWMgr(zend_property_reference *property_reference, pval *value);
static int _propset_SWMgr(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWMgr(zend_property_reference *property_reference);
static int _propget_SWMgr(zend_property_reference *property_reference, pval *value);

 #include "swmodule.h"

bool const SWModule_next(SWModule *self){
	(*self)++;
	return !self->Error();
  }
bool const SWModule_prev(SWModule *self){
	(*self)--;
	return !self->Error();
  }
bool const SWModule_inc(SWModule *self,int const howFar){
  	(*self)+=howFar;
	return !self->Error();
  }
bool const SWModule_dec(SWModule *self,int const howFar){
  	(*self)-=howFar;
	return !self->Error();
  }
void SWModule_setPosition(SWModule *self,SW_POSITION pos){
  	(*self) = pos;
  }
void SWModule_top(SWModule *self){
	(*self) = TOP;
  }
void SWModule_bottom(SWModule *self){
	(*self) = BOTTOM;
  }
char const *SWModule_text(SWModule *self){
  	return (const char*)*self;
  }
char const *SWModule_StripText(SWModule *self){
  	return self->StripText();
  }
void SWModule_write(SWModule *self,char const *text){
    (*self)<<text;
  }
void SWModule_writeLink(SWModule *self,SWKey const *key){
    (*self)<<key;
  }
static int _wrap_propset_SWModule(zend_property_reference *property_reference, pval *value);
static int _propset_SWModule(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWModule(zend_property_reference *property_reference);
static int _propget_SWModule(zend_property_reference *property_reference, pval *value);

 #include "swkey.h"

static int _wrap_propset_SW_POSITION(zend_property_reference *property_reference, pval *value);
static int _propset_SW_POSITION(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SW_POSITION(zend_property_reference *property_reference);
static int _propget_SW_POSITION(zend_property_reference *property_reference, pval *value);
void SWKey_setPersist(SWKey *self,signed char persists){
  	self->Persist(persists);
  }
void SWKey_next(SWKey *self){
  	(*self)++;
  }
void SWKey_prev(SWKey *self){
  	(*self)++;
  }
void SWKey_setKey(SWKey *self,SWKey const *key){
  	self->copyFrom(*key);
  }
static int _wrap_propset_SWKey(zend_property_reference *property_reference, pval *value);
static int _propset_SWKey(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWKey(zend_property_reference *property_reference);
static int _propget_SWKey(zend_property_reference *property_reference, pval *value);

 #include "versekey.h"

static int _wrap_propset_VerseKey(zend_property_reference *property_reference, pval *value);
static int _propset_VerseKey(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_VerseKey(zend_property_reference *property_reference);
static int _propget_VerseKey(zend_property_reference *property_reference, pval *value);

#include "listkey.h"

unsigned char ListKey_SetToElement(ListKey *self,int element){
		return self->SetToElement(element, SW_POSITION(((char)1)));
	}
static int _wrap_propset_ListKey(zend_property_reference *property_reference, pval *value);
static int _propset_ListKey(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_ListKey(zend_property_reference *property_reference);
static int _propget_ListKey(zend_property_reference *property_reference, pval *value);

#include "treekey.h"

static int _wrap_propset_TreeKey(zend_property_reference *property_reference, pval *value);
static int _propset_TreeKey(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_TreeKey(zend_property_reference *property_reference);
static int _propget_TreeKey(zend_property_reference *property_reference, pval *value);

#include "treekeyidx.h"

static int _wrap_propset_TreeKeyIdx(zend_property_reference *property_reference, pval *value);
static int _propset_TreeKeyIdx(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_TreeKeyIdx(zend_property_reference *property_reference);
static int _propget_TreeKeyIdx(zend_property_reference *property_reference, pval *value);

#include <localemgr.h>

LocaleMgr *const LocaleMgr_systemLocaleMgr(LocaleMgr *self){
  	return &(LocaleMgr::systemLocaleMgr);
  }
static int _wrap_propset_LocaleMgr(zend_property_reference *property_reference, pval *value);
static int _propset_LocaleMgr(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LocaleMgr(zend_property_reference *property_reference);
static int _propget_LocaleMgr(zend_property_reference *property_reference, pval *value);

#include <swfiltermgr.h>

static int _wrap_propset_SWFilterMgr(zend_property_reference *property_reference, pval *value);
static int _propset_SWFilterMgr(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWFilterMgr(zend_property_reference *property_reference);
static int _propget_SWFilterMgr(zend_property_reference *property_reference, pval *value);

 #include "swtext.h"

static int _wrap_propset_SWText(zend_property_reference *property_reference, pval *value);
static int _propset_SWText(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWText(zend_property_reference *property_reference);
static int _propget_SWText(zend_property_reference *property_reference, pval *value);

 #include "rawtext.h"

static int _wrap_propset_RawText(zend_property_reference *property_reference, pval *value);
static int _propset_RawText(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_RawText(zend_property_reference *property_reference);
static int _propget_RawText(zend_property_reference *property_reference, pval *value);

 #include "ztext.h"

static int _wrap_propset_zText(zend_property_reference *property_reference, pval *value);
static int _propset_zText(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_zText(zend_property_reference *property_reference);
static int _propget_zText(zend_property_reference *property_reference, pval *value);

 #include "swcom.h"

static int _wrap_propset_SWCom(zend_property_reference *property_reference, pval *value);
static int _propset_SWCom(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWCom(zend_property_reference *property_reference);
static int _propget_SWCom(zend_property_reference *property_reference, pval *value);

 #include "rawcom.h"

static int _wrap_propset_RawCom(zend_property_reference *property_reference, pval *value);
static int _propset_RawCom(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_RawCom(zend_property_reference *property_reference);
static int _propget_RawCom(zend_property_reference *property_reference, pval *value);

 #include "zcom.h"

static int _wrap_propset_zCom(zend_property_reference *property_reference, pval *value);
static int _propset_zCom(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_zCom(zend_property_reference *property_reference);
static int _propget_zCom(zend_property_reference *property_reference, pval *value);

 #include "swgenbook.h"

static int _wrap_propset_SWGenBook(zend_property_reference *property_reference, pval *value);
static int _propset_SWGenBook(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWGenBook(zend_property_reference *property_reference);
static int _propget_SWGenBook(zend_property_reference *property_reference, pval *value);

 #include "rawgenbook.h"

static int _wrap_propset_RawGenBook(zend_property_reference *property_reference, pval *value);
static int _propset_RawGenBook(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_RawGenBook(zend_property_reference *property_reference);
static int _propget_RawGenBook(zend_property_reference *property_reference, pval *value);

 #include "swld.h"

static int _wrap_propset_SWLD(zend_property_reference *property_reference, pval *value);
static int _propset_SWLD(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWLD(zend_property_reference *property_reference);
static int _propget_SWLD(zend_property_reference *property_reference, pval *value);

 #include "rawld.h"

static int _wrap_propset_RawLD(zend_property_reference *property_reference, pval *value);
static int _propset_RawLD(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_RawLD(zend_property_reference *property_reference);
static int _propget_RawLD(zend_property_reference *property_reference, pval *value);

 #include "rawld4.h"

static int _wrap_propset_RawLD4(zend_property_reference *property_reference, pval *value);
static int _propset_RawLD4(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_RawLD4(zend_property_reference *property_reference);
static int _propget_RawLD4(zend_property_reference *property_reference, pval *value);

 #include "zld.h"

static int _wrap_propset_zLD(zend_property_reference *property_reference, pval *value);
static int _propset_zLD(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_zLD(zend_property_reference *property_reference);
static int _propget_zLD(zend_property_reference *property_reference, pval *value);

 #include <swcomprs.h>

static int _wrap_propset_SWCompress(zend_property_reference *property_reference, pval *value);
static int _propset_SWCompress(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_SWCompress(zend_property_reference *property_reference);
static int _propget_SWCompress(zend_property_reference *property_reference, pval *value);

 #include <lzsscomprs.h>

static int _wrap_propset_LZSSCompress(zend_property_reference *property_reference, pval *value);
static int _propset_LZSSCompress(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_LZSSCompress(zend_property_reference *property_reference);
static int _propget_LZSSCompress(zend_property_reference *property_reference, pval *value);

 #include <zipcomprs.h>

static int _wrap_propset_ZipCompress(zend_property_reference *property_reference, pval *value);
static int _propset_ZipCompress(zend_property_reference *property_reference, pval *value);
static pval _wrap_propget_ZipCompress(zend_property_reference *property_reference);
static int _propget_ZipCompress(zend_property_reference *property_reference, pval *value);
/* class entry subsection */
// Function entries for SWConfig
static zend_function_entry SWConfig_functions[] = {
	ZEND_NAMED_FE(swconfig,
		_wrap_new_SWConfig, NULL)
	ZEND_NAMED_FE(load,
		_wrap_SWConfig_Load, NULL)
	ZEND_NAMED_FE(save,
		_wrap_SWConfig_Save, NULL)
	ZEND_NAMED_FE(set,
		_wrap_SWConfig_set, NULL)
	ZEND_NAMED_FE(get,
		_wrap_SWConfig_get, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SWMgr
static zend_function_entry SWMgr_functions[] = {
	ZEND_NAMED_FE(findconfig,
		_wrap_SWMgr_findConfig, NULL)
	ZEND_NAMED_FE(swmgr,
		_wrap_new_SWMgr, NULL)
	ZEND_NAMED_FE(load,
		_wrap_SWMgr_Load, NULL)
	ZEND_NAMED_FE(setglobaloption,
		_wrap_SWMgr_setGlobalOption, NULL)
	ZEND_NAMED_FE(getglobaloption,
		_wrap_SWMgr_getGlobalOption, NULL)
	ZEND_NAMED_FE(getglobaloptiontip,
		_wrap_SWMgr_getGlobalOptionTip, NULL)
	ZEND_NAMED_FE(getglobaloptions,
		_wrap_SWMgr_getGlobalOptions, NULL)
	ZEND_NAMED_FE(getglobaloptionvalues,
		_wrap_SWMgr_getGlobalOptionValues, NULL)
	ZEND_NAMED_FE(setcipherkey,
		_wrap_SWMgr_setCipherKey, NULL)
	ZEND_NAMED_FE(module,
		_wrap_SWMgr_module, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SWModule
static zend_function_entry SWModule_functions[] = {
	ZEND_NAMED_FE(swmodule,
		_wrap_new_SWModule, NULL)
	ZEND_NAMED_FE(error,
		_wrap_SWModule_Error, NULL)
	ZEND_NAMED_FE(isunicode,
		_wrap_SWModule_isUnicode, NULL)
	ZEND_NAMED_FE(getconfig,
		_wrap_SWModule_getConfig, NULL)
	ZEND_NAMED_FE(getconfigentry,
		_wrap_SWModule_getConfigEntry, NULL)
	ZEND_NAMED_FE(setkey,
		_wrap_SWModule_SetKey, NULL)
	ZEND_NAMED_FE(key,
		_wrap_SWModule_Key, NULL)
	ZEND_NAMED_FE(createkey,
		_wrap_SWModule_CreateKey, NULL)
	ZEND_NAMED_FE(keytext,
		_wrap_SWModule_KeyText, NULL)
	ZEND_NAMED_FE(display,
		_wrap_SWModule_Display, NULL)
	ZEND_NAMED_FE(nullpercent,
		_wrap_SWModule_nullPercent, NULL)
	ZEND_NAMED_FE(search,
		_wrap_SWModule_Search, NULL)
	ZEND_NAMED_FE(createsearchframework,
		_wrap_SWModule_createSearchFramework, NULL)
	ZEND_NAMED_FE(hassearchframework,
		_wrap_SWModule_hasSearchFramework, NULL)
	ZEND_NAMED_FE(issearchoptimallysupported,
		_wrap_SWModule_isSearchOptimallySupported, NULL)
	ZEND_NAMED_FE(next,
		_wrap_SWModule_next, NULL)
	ZEND_NAMED_FE(prev,
		_wrap_SWModule_prev, NULL)
	ZEND_NAMED_FE(inc,
		_wrap_SWModule_inc, NULL)
	ZEND_NAMED_FE(dec,
		_wrap_SWModule_dec, NULL)
	ZEND_NAMED_FE(setposition,
		_wrap_SWModule_setPosition, NULL)
	ZEND_NAMED_FE(top,
		_wrap_SWModule_top, NULL)
	ZEND_NAMED_FE(bottom,
		_wrap_SWModule_bottom, NULL)
	ZEND_NAMED_FE(text,
		_wrap_SWModule_text, NULL)
	ZEND_NAMED_FE(striptext,
		_wrap_SWModule_StripText, NULL)
	ZEND_NAMED_FE(getrawentry,
		_wrap_SWModule_getRawEntry, NULL)
	ZEND_NAMED_FE(setskipconsecutivelinks,
		_wrap_SWModule_setSkipConsecutiveLinks, NULL)
	ZEND_NAMED_FE(getskipconsecutivelinks,
		_wrap_SWModule_getSkipConsecutiveLinks, NULL)
	ZEND_NAMED_FE(getentryattributes,
		_wrap_SWModule_getEntryAttributes, NULL)
	ZEND_NAMED_FE(processentryattributes,
		_wrap_SWModule_processEntryAttributes, NULL)
	ZEND_NAMED_FE(isprocessentryattributes,
		_wrap_SWModule_isProcessEntryAttributes, NULL)
	ZEND_NAMED_FE(name,
		_wrap_SWModule_Name, NULL)
	ZEND_NAMED_FE(description,
		_wrap_SWModule_Description, NULL)
	ZEND_NAMED_FE(type,
		_wrap_SWModule_Type, NULL)
	ZEND_NAMED_FE(direction,
		_wrap_SWModule_Direction, NULL)
	ZEND_NAMED_FE(encoding,
		_wrap_SWModule_Encoding, NULL)
	ZEND_NAMED_FE(markup,
		_wrap_SWModule_Markup, NULL)
	ZEND_NAMED_FE(lang,
		_wrap_SWModule_Lang, NULL)
	ZEND_NAMED_FE(iswritable,
		_wrap_SWModule_isWritable, NULL)
	ZEND_NAMED_FE(createmodule,
		_wrap_SWModule_createModule, NULL)
	ZEND_NAMED_FE(setentry,
		_wrap_SWModule_setEntry, NULL)
	ZEND_NAMED_FE(deleteentry,
		_wrap_SWModule_deleteEntry, NULL)
	ZEND_NAMED_FE(write,
		_wrap_SWModule_write, NULL)
	ZEND_NAMED_FE(writelink,
		_wrap_SWModule_writeLink, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SW_POSITION
static zend_function_entry SW_POSITION_functions[] = {
	ZEND_NAMED_FE(sw_position,
		_wrap_new_SW_POSITION, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SWKey
static zend_function_entry SWKey_functions[] = {
	ZEND_NAMED_FE(swkey,
		_wrap_new_SWKey, NULL)
	ZEND_NAMED_FE(clone,
		_wrap_SWKey_clone, NULL)
	ZEND_NAMED_FE(persist,
		_wrap_SWKey_Persist, NULL)
	ZEND_NAMED_FE(setpersist,
		_wrap_SWKey_setPersist, NULL)
	ZEND_NAMED_FE(error,
		_wrap_SWKey_Error, NULL)
	ZEND_NAMED_FE(settext,
		_wrap_SWKey_setText, NULL)
	ZEND_NAMED_FE(gettext,
		_wrap_SWKey_getText, NULL)
	ZEND_NAMED_FE(getshorttext,
		_wrap_SWKey_getShortText, NULL)
	ZEND_NAMED_FE(compare,
		_wrap_SWKey_compare, NULL)
	ZEND_NAMED_FE(equals,
		_wrap_SWKey_equals, NULL)
	ZEND_NAMED_FE(decrement,
		_wrap_SWKey_decrement, NULL)
	ZEND_NAMED_FE(increment,
		_wrap_SWKey_increment, NULL)
	ZEND_NAMED_FE(traversable,
		_wrap_SWKey_Traversable, NULL)
	ZEND_NAMED_FE(index,
		_wrap_SWKey_Index, NULL)
	ZEND_NAMED_FE(next,
		_wrap_SWKey_next, NULL)
	ZEND_NAMED_FE(prev,
		_wrap_SWKey_prev, NULL)
	ZEND_NAMED_FE(setkey,
		_wrap_SWKey_setKey, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for VerseKey
static zend_function_entry VerseKey_functions[] = {
	ZEND_NAMED_FE(versekey,
		_wrap_new_VerseKey, NULL)
	ZEND_NAMED_FE(clone,
		_wrap_VerseKey_clone, NULL)
	ZEND_NAMED_FE(lowerbound,
		_wrap_VerseKey_LowerBound, NULL)
	ZEND_NAMED_FE(upperbound,
		_wrap_VerseKey_UpperBound, NULL)
	ZEND_NAMED_FE(clearbounds,
		_wrap_VerseKey_ClearBounds, NULL)
	ZEND_NAMED_FE(decrement,
		_wrap_VerseKey_decrement, NULL)
	ZEND_NAMED_FE(increment,
		_wrap_VerseKey_increment, NULL)
	ZEND_NAMED_FE(traversable,
		_wrap_VerseKey_Traversable, NULL)
	ZEND_NAMED_FE(getbookname,
		_wrap_VerseKey_getBookName, NULL)
	ZEND_NAMED_FE(getbookabbrev,
		_wrap_VerseKey_getBookAbbrev, NULL)
	ZEND_NAMED_FE(testament,
		_wrap_VerseKey_Testament, NULL)
	ZEND_NAMED_FE(book,
		_wrap_VerseKey_Book, NULL)
	ZEND_NAMED_FE(chapter,
		_wrap_VerseKey_Chapter, NULL)
	ZEND_NAMED_FE(verse,
		_wrap_VerseKey_Verse, NULL)
	ZEND_NAMED_FE(normalize,
		_wrap_VerseKey_Normalize, NULL)
	ZEND_NAMED_FE(autonormalize,
		_wrap_VerseKey_AutoNormalize, NULL)
	ZEND_NAMED_FE(headings,
		_wrap_VerseKey_Headings, NULL)
	ZEND_NAMED_FE(getosisref,
		_wrap_VerseKey_getOSISRef, NULL)
	ZEND_NAMED_FE(compare,
		_wrap_VerseKey_compare, NULL)
	ZEND_NAMED_FE(_compare,
		_wrap_VerseKey__compare, NULL)
	ZEND_NAMED_FE(setlocale,
		_wrap_VerseKey_setLocale, NULL)
	ZEND_NAMED_FE(getlocale,
		_wrap_VerseKey_getLocale, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for ListKey
static zend_function_entry ListKey_functions[] = {
	ZEND_NAMED_FE(listkey,
		_wrap_new_ListKey, NULL)
	ZEND_NAMED_FE(clone,
		_wrap_ListKey_clone, NULL)
	ZEND_NAMED_FE(clearlist,
		_wrap_ListKey_ClearList, NULL)
	ZEND_NAMED_FE(count,
		_wrap_ListKey_Count, NULL)
	ZEND_NAMED_FE(remove,
		_wrap_ListKey_Remove, NULL)
	ZEND_NAMED_FE(settoelement,
		_wrap_ListKey_SetToElement, NULL)
	ZEND_NAMED_FE(getelement,
		_wrap_ListKey_GetElement, NULL)
	ZEND_NAMED_FE(add,
		_wrap_ListKey_add, NULL)
	ZEND_NAMED_FE(copyfrom,
		_wrap_ListKey_copyFrom, NULL)
	ZEND_NAMED_FE(setposition,
		_wrap_ListKey_setPosition, NULL)
	ZEND_NAMED_FE(decrement,
		_wrap_ListKey_decrement, NULL)
	ZEND_NAMED_FE(increment,
		_wrap_ListKey_increment, NULL)
	ZEND_NAMED_FE(traversable,
		_wrap_ListKey_Traversable, NULL)
	ZEND_NAMED_FE(index,
		_wrap_ListKey_Index, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for TreeKey
static zend_function_entry TreeKey_functions[] = {
	ZEND_NAMED_FE(getlocalname,
		_wrap_TreeKey_getLocalName, NULL)
	ZEND_NAMED_FE(setlocalname,
		_wrap_TreeKey_setLocalName, NULL)
	ZEND_NAMED_FE(getuserdata,
		_wrap_TreeKey_getUserData, NULL)
	ZEND_NAMED_FE(setuserdata,
		_wrap_TreeKey_setUserData, NULL)
	ZEND_NAMED_FE(getfullname,
		_wrap_TreeKey_getFullName, NULL)
	ZEND_NAMED_FE(root,
		_wrap_TreeKey_root, NULL)
	ZEND_NAMED_FE(parent,
		_wrap_TreeKey_parent, NULL)
	ZEND_NAMED_FE(firstchild,
		_wrap_TreeKey_firstChild, NULL)
	ZEND_NAMED_FE(nextsibling,
		_wrap_TreeKey_nextSibling, NULL)
	ZEND_NAMED_FE(previoussibling,
		_wrap_TreeKey_previousSibling, NULL)
	ZEND_NAMED_FE(haschildren,
		_wrap_TreeKey_hasChildren, NULL)
	ZEND_NAMED_FE(append,
		_wrap_TreeKey_append, NULL)
	ZEND_NAMED_FE(appendchild,
		_wrap_TreeKey_appendChild, NULL)
	ZEND_NAMED_FE(insertbefore,
		_wrap_TreeKey_insertBefore, NULL)
	ZEND_NAMED_FE(remove,
		_wrap_TreeKey_remove, NULL)
	ZEND_NAMED_FE(setoffset,
		_wrap_TreeKey_setOffset, NULL)
	ZEND_NAMED_FE(getoffset,
		_wrap_TreeKey_getOffset, NULL)
	ZEND_NAMED_FE(setposition,
		_wrap_TreeKey_setPosition, NULL)
	ZEND_NAMED_FE(traversable,
		_wrap_TreeKey_Traversable, NULL)
	ZEND_NAMED_FE(index,
		_wrap_TreeKey_Index, NULL)
	ZEND_NAMED_FE(treekey,
		_wrap_new_TreeKey, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for TreeKeyIdx
static zend_function_entry TreeKeyIdx_functions[] = {
	ZEND_NAMED_FE(treekeyidx,
		_wrap_new_TreeKeyIdx, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for LocaleMgr
static zend_function_entry LocaleMgr_functions[] = {
	ZEND_NAMED_FE(localemgr,
		_wrap_new_LocaleMgr, NULL)
	ZEND_NAMED_FE(getlocale,
		_wrap_LocaleMgr_getLocale, NULL)
	ZEND_NAMED_FE(getavailablelocales,
		_wrap_LocaleMgr_getAvailableLocales, NULL)
	ZEND_NAMED_FE(getdefaultlocalename,
		_wrap_LocaleMgr_getDefaultLocaleName, NULL)
	ZEND_NAMED_FE(setdefaultlocalename,
		_wrap_LocaleMgr_setDefaultLocaleName, NULL)
	ZEND_NAMED_FE(systemlocalemgr,
		_wrap_LocaleMgr_systemLocaleMgr, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SWFilterMgr
static zend_function_entry SWFilterMgr_functions[] = {
	ZEND_NAMED_FE(swfiltermgr,
		_wrap_new_SWFilterMgr, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SWText
static zend_function_entry SWText_functions[] = {
	ZEND_NAMED_FE(swtext,
		_wrap_new_SWText, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for RawText
static zend_function_entry RawText_functions[] = {
	ZEND_NAMED_FE(rawtext,
		_wrap_new_RawText, NULL)
	ZEND_NAMED_FE(createmodule,
		_wrap_RawText_createModule, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for zText
static zend_function_entry zText_functions[] = {
	ZEND_NAMED_FE(ztext,
		_wrap_new_zText, NULL)
	ZEND_NAMED_FE(createmodule,
		_wrap_zText_createModule, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SWCom
static zend_function_entry SWCom_functions[] = {
	ZEND_NAMED_FE(swcom,
		_wrap_new_SWCom, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for RawCom
static zend_function_entry RawCom_functions[] = {
	ZEND_NAMED_FE(rawcom,
		_wrap_new_RawCom, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for zCom
static zend_function_entry zCom_functions[] = {
	ZEND_NAMED_FE(zcom,
		_wrap_new_zCom, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SWGenBook
static zend_function_entry SWGenBook_functions[] = {
	ZEND_NAMED_FE(swgenbook,
		_wrap_new_SWGenBook, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for RawGenBook
static zend_function_entry RawGenBook_functions[] = {
	ZEND_NAMED_FE(rawgenbook,
		_wrap_new_RawGenBook, NULL)
	ZEND_NAMED_FE(createmodule,
		_wrap_RawGenBook_createModule, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SWLD
static zend_function_entry SWLD_functions[] = {
	ZEND_NAMED_FE(swld,
		_wrap_new_SWLD, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for RawLD
static zend_function_entry RawLD_functions[] = {
	ZEND_NAMED_FE(rawld,
		_wrap_new_RawLD, NULL)
	ZEND_NAMED_FE(createmodule,
		_wrap_RawLD_createModule, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for RawLD4
static zend_function_entry RawLD4_functions[] = {
	ZEND_NAMED_FE(rawld4,
		_wrap_new_RawLD4, NULL)
	ZEND_NAMED_FE(createmodule,
		_wrap_RawLD4_createModule, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for zLD
static zend_function_entry zLD_functions[] = {
	ZEND_NAMED_FE(zld,
		_wrap_new_zLD, NULL)
	ZEND_NAMED_FE(createmodule,
		_wrap_zLD_createModule, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for SWCompress
static zend_function_entry SWCompress_functions[] = {
	ZEND_NAMED_FE(swcompress,
		_wrap_new_SWCompress, NULL)
	ZEND_NAMED_FE(buf,
		_wrap_SWCompress_Buf, NULL)
	ZEND_NAMED_FE(zbuf,
		_wrap_SWCompress_zBuf, NULL)
	ZEND_NAMED_FE(getchars,
		_wrap_SWCompress_GetChars, NULL)
	ZEND_NAMED_FE(sendchars,
		_wrap_SWCompress_SendChars, NULL)
	ZEND_NAMED_FE(encode,
		_wrap_SWCompress_Encode, NULL)
	ZEND_NAMED_FE(decode,
		_wrap_SWCompress_Decode, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for LZSSCompress
static zend_function_entry LZSSCompress_functions[] = {
	ZEND_NAMED_FE(lzsscompress,
		_wrap_new_LZSSCompress, NULL)
	ZEND_NAMED_FE(encode,
		_wrap_LZSSCompress_Encode, NULL)
	ZEND_NAMED_FE(decode,
		_wrap_LZSSCompress_Decode, NULL)
	{ NULL, NULL, NULL}
};
// Function entries for ZipCompress
static zend_function_entry ZipCompress_functions[] = {
	ZEND_NAMED_FE(zipcompress,
		_wrap_new_ZipCompress, NULL)
	ZEND_NAMED_FE(encode,
		_wrap_ZipCompress_Encode, NULL)
	ZEND_NAMED_FE(decode,
		_wrap_ZipCompress_Decode, NULL)
	{ NULL, NULL, NULL}
};


/* entry subsection */
/* Every non-class user visible function must have an entry here */
function_entry Sword_functions[] = {
	{NULL, NULL, NULL}
};

zend_module_entry Sword_module_entry = {
#if ZEND_MODULE_API_NO > 20010900
    STANDARD_MODULE_HEADER,
#endif
    "Sword",
    Sword_functions,
    PHP_MINIT(Sword),
    PHP_MSHUTDOWN(Sword),
    PHP_RINIT(Sword),
    PHP_RSHUTDOWN(Sword),
    PHP_MINFO(Sword),
#if ZEND_MODULE_API_NO > 20010900
    NO_VERSION_YET,
#endif
    STANDARD_MODULE_PROPERTIES
};
zend_module_entry* SWIG_module_entry = &Sword_module_entry;


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_zComTo_p_SWCom(void *x) {
    return (void *)((SWCom *)  ((zCom *) x));
}
static void *_p_RawComTo_p_SWCom(void *x) {
    return (void *)((SWCom *)  ((RawCom *) x));
}
static void *_p_TreeKeyIdxTo_p_TreeKey(void *x) {
    return (void *)((TreeKey *)  ((TreeKeyIdx *) x));
}
static void *_p_RawTextTo_p_SWText(void *x) {
    return (void *)((SWText *)  ((RawText *) x));
}
static void *_p_zTextTo_p_SWText(void *x) {
    return (void *)((SWText *)  ((zText *) x));
}
static void *_p_ListKeyTo_p_SWKey(void *x) {
    return (void *)((SWKey *)  ((ListKey *) x));
}
static void *_p_TreeKeyIdxTo_p_SWKey(void *x) {
    return (void *)((SWKey *) (TreeKey *) ((TreeKeyIdx *) x));
}
static void *_p_VerseKeyTo_p_SWKey(void *x) {
    return (void *)((SWKey *)  ((VerseKey *) x));
}
static void *_p_TreeKeyTo_p_SWKey(void *x) {
    return (void *)((SWKey *)  ((TreeKey *) x));
}
static void *_p_LZSSCompressTo_p_SWCompress(void *x) {
    return (void *)((SWCompress *)  ((LZSSCompress *) x));
}
static void *_p_ZipCompressTo_p_SWCompress(void *x) {
    return (void *)((SWCompress *)  ((ZipCompress *) x));
}
static void *_p_SWComTo_p_SWModule(void *x) {
    return (void *)((SWModule *)  ((SWCom *) x));
}
static void *_p_zLDTo_p_SWModule(void *x) {
    return (void *)((SWModule *) (SWLD *) ((zLD *) x));
}
static void *_p_SWTextTo_p_SWModule(void *x) {
    return (void *)((SWModule *)  ((SWText *) x));
}
static void *_p_SWGenBookTo_p_SWModule(void *x) {
    return (void *)((SWModule *)  ((SWGenBook *) x));
}
static void *_p_RawGenBookTo_p_SWModule(void *x) {
    return (void *)((SWModule *) (SWGenBook *) ((RawGenBook *) x));
}
static void *_p_RawTextTo_p_SWModule(void *x) {
    return (void *)((SWModule *) (SWText *) ((RawText *) x));
}
static void *_p_zComTo_p_SWModule(void *x) {
    return (void *)((SWModule *) (SWCom *) ((zCom *) x));
}
static void *_p_RawLD4To_p_SWModule(void *x) {
    return (void *)((SWModule *) (SWLD *) ((RawLD4 *) x));
}
static void *_p_zTextTo_p_SWModule(void *x) {
    return (void *)((SWModule *) (SWText *) ((zText *) x));
}
static void *_p_RawComTo_p_SWModule(void *x) {
    return (void *)((SWModule *) (SWCom *) ((RawCom *) x));
}
static void *_p_SWLDTo_p_SWModule(void *x) {
    return (void *)((SWModule *)  ((SWLD *) x));
}
static void *_p_RawLDTo_p_SWModule(void *x) {
    return (void *)((SWModule *) (SWLD *) ((RawLD *) x));
}
static void *_p_RawGenBookTo_p_SWGenBook(void *x) {
    return (void *)((SWGenBook *)  ((RawGenBook *) x));
}
static void *_p_zLDTo_p_SWLD(void *x) {
    return (void *)((SWLD *)  ((zLD *) x));
}
static void *_p_RawLD4To_p_SWLD(void *x) {
    return (void *)((SWLD *)  ((RawLD4 *) x));
}
static void *_p_RawLDTo_p_SWLD(void *x) {
    return (void *)((SWLD *)  ((RawLD *) x));
}
static swig_type_info _swigt__p_SWLocale[] = {{"_p_SWLocale", 0, "SWLocale *", 0},{"_p_SWLocale"},{0}};
static swig_type_info _swigt__p_SWMgr[] = {{"_p_SWMgr", 0, "SWMgr *", 0},{"_p_SWMgr"},{0}};
static swig_type_info _swigt__p_SWCom[] = {{"_p_SWCom", 0, "SWCom *", 0},{"_p_zCom", _p_zComTo_p_SWCom},{"_p_SWCom"},{"_p_RawCom", _p_RawComTo_p_SWCom},{0}};
static swig_type_info _swigt__p_RawLD4[] = {{"_p_RawLD4", 0, "RawLD4 *", 0},{"_p_RawLD4"},{0}};
static swig_type_info _swigt__p_ListKey[] = {{"_p_ListKey", 0, "ListKey *", 0},{"_p_ListKey"},{0}};
static swig_type_info _swigt__p_SWKey[] = {{"_p_SWKey", 0, "SWKey *", 0},{"_p_SWKey"},{"_p_ListKey", _p_ListKeyTo_p_SWKey},{"_p_TreeKeyIdx", _p_TreeKeyIdxTo_p_SWKey},{"_p_VerseKey", _p_VerseKeyTo_p_SWKey},{"_p_TreeKey", _p_TreeKeyTo_p_SWKey},{0}};
static swig_type_info _swigt__p_ConfigEntMap[] = {{"_p_ConfigEntMap", 0, "ConfigEntMap const &", 0},{"_p_ConfigEntMap"},{0}};
static swig_type_info _swigt__p_p_char[] = {{"_p_p_char", 0, "char **", 0},{"_p_p_char"},{0}};
static swig_type_info _swigt__p_RawLD[] = {{"_p_RawLD", 0, "RawLD *", 0},{"_p_RawLD"},{0}};
static swig_type_info _swigt__p_TreeKey[] = {{"_p_TreeKey", 0, "TreeKey *", 0},{"_p_TreeKeyIdx", _p_TreeKeyIdxTo_p_TreeKey},{"_p_TreeKey"},{0}};
static swig_type_info _swigt__p_bool[] = {{"_p_bool", 0, "bool *", 0},{"_p_bool"},{0}};
static swig_type_info _swigt__p_void[] = {{"_p_void", 0, "void *", 0},{"_p_void"},{0}};
static swig_type_info _swigt__p_SWFilterMgr[] = {{"_p_SWFilterMgr", 0, "SWFilterMgr *", 0},{"_p_SWFilterMgr"},{0}};
static swig_type_info _swigt__p_SWLD[] = {{"_p_SWLD", 0, "SWLD *", 0},{"_p_zLD", _p_zLDTo_p_SWLD},{"_p_SWLD"},{"_p_RawLD4", _p_RawLD4To_p_SWLD},{"_p_RawLD", _p_RawLDTo_p_SWLD},{0}};
static swig_type_info _swigt__p_SWTextDirection[] = {{"_p_SWTextDirection", 0, "SWTextDirection *", 0},{"_p_SWTextDirection"},{0}};
static swig_type_info _swigt__p_RawText[] = {{"_p_RawText", 0, "RawText *", 0},{"_p_RawText"},{0}};
static swig_type_info _swigt__p_f_char_p_void__void[] = {{"_p_f_char_p_void__void", 0, "void (*)(char,void *)", 0},{"_p_f_char_p_void__void"},{0}};
static swig_type_info _swigt__p_VerseKey[] = {{"_p_VerseKey", 0, "VerseKey *", 0},{"_p_VerseKey"},{0}};
static swig_type_info _swigt__p_ModMap[] = {{"_p_ModMap", 0, "ModMap *", 0},{"_p_ModMap"},{0}};
static swig_type_info _swigt__p_string[] = {{"_p_string", 0, "string *", 0},{"_p_string"},{0}};
static swig_type_info _swigt__p_SectionMap[] = {{"_p_SectionMap", 0, "SectionMap *", 0},{"_p_SectionMap"},{0}};
static swig_type_info _swigt__p_SWDisplay[] = {{"_p_SWDisplay", 0, "SWDisplay *", 0},{"_p_SWDisplay"},{0}};
static swig_type_info _swigt__p_AttributeTypeList[] = {{"_p_AttributeTypeList", 0, "AttributeTypeList *", 0},{"_p_AttributeTypeList"},{0}};
static swig_type_info _swigt__p_SWText[] = {{"_p_SWText", 0, "SWText *", 0},{"_p_SWText"},{"_p_RawText", _p_RawTextTo_p_SWText},{"_p_zText", _p_zTextTo_p_SWText},{0}};
static swig_type_info _swigt__p_SWCompress[] = {{"_p_SWCompress", 0, "SWCompress *", 0},{"_p_SWCompress"},{"_p_LZSSCompress", _p_LZSSCompressTo_p_SWCompress},{"_p_ZipCompress", _p_ZipCompressTo_p_SWCompress},{0}};
static swig_type_info _swigt__p_LZSSCompress[] = {{"_p_LZSSCompress", 0, "LZSSCompress *", 0},{"_p_LZSSCompress"},{0}};
static swig_type_info _swigt__p_ZipCompress[] = {{"_p_ZipCompress", 0, "ZipCompress *", 0},{"_p_ZipCompress"},{0}};
static swig_type_info _swigt__p_SW_POSITION[] = {{"_p_SW_POSITION", 0, "SW_POSITION *", 0},{"_p_SW_POSITION"},{0}};
static swig_type_info _swigt__p_SWModule[] = {{"_p_SWModule", 0, "SWModule *", 0},{"_p_SWModule"},{"_p_SWGenBook", _p_SWGenBookTo_p_SWModule},{"_p_RawGenBook", _p_RawGenBookTo_p_SWModule},{"_p_SWText", _p_SWTextTo_p_SWModule},{"_p_RawText", _p_RawTextTo_p_SWModule},{"_p_zLD", _p_zLDTo_p_SWModule},{"_p_zCom", _p_zComTo_p_SWModule},{"_p_zText", _p_zTextTo_p_SWModule},{"_p_RawLD4", _p_RawLD4To_p_SWModule},{"_p_SWLD", _p_SWLDTo_p_SWModule},{"_p_RawLD", _p_RawLDTo_p_SWModule},{"_p_SWCom", _p_SWComTo_p_SWModule},{"_p_RawCom", _p_RawComTo_p_SWModule},{0}};
static swig_type_info _swigt__p_zLD[] = {{"_p_zLD", 0, "zLD *", 0},{"_p_zLD"},{0}};
static swig_type_info _swigt__p_SWGenBook[] = {{"_p_SWGenBook", 0, "SWGenBook *", 0},{"_p_SWGenBook"},{"_p_RawGenBook", _p_RawGenBookTo_p_SWGenBook},{0}};
static swig_type_info _swigt__p_RawGenBook[] = {{"_p_RawGenBook", 0, "RawGenBook *", 0},{"_p_RawGenBook"},{0}};
static swig_type_info _swigt__p_SWConfig[] = {{"_p_SWConfig", 0, "SWConfig *", 0},{"_p_SWConfig"},{0}};
static swig_type_info _swigt__p_LocaleMgr[] = {{"_p_LocaleMgr", 0, "LocaleMgr *", 0},{"_p_LocaleMgr"},{0}};
static swig_type_info _swigt__p_int[] = {{"_p_int", 0, "int *", 0},{"_p_int"},{0}};
static swig_type_info _swigt__p_SWTextMarkup[] = {{"_p_SWTextMarkup", 0, "SWTextMarkup *", 0},{"_p_SWTextMarkup"},{0}};
static swig_type_info _swigt__p_OptionsList[] = {{"_p_OptionsList", 0, "OptionsList *", 0},{"_p_listTstring_t"},{"_p_OptionsList"},{0}};
static swig_type_info _swigt__p_listTstring_t[] = {{"_p_listTstring_t", 0, "list<string > *", 0},{"_p_listTstring_t"},{"_p_OptionsList"},{0}};
static swig_type_info _swigt__p_zText[] = {{"_p_zText", 0, "zText *", 0},{"_p_zText"},{0}};
static swig_type_info _swigt__p_SWTextEncoding[] = {{"_p_SWTextEncoding", 0, "SWTextEncoding *", 0},{"_p_SWTextEncoding"},{0}};
static swig_type_info _swigt__p_unsigned_long[] = {{"_p_unsigned_long", 0, "unsigned long *", 0},{"_p_unsigned_long"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_SWLocale, 
_swigt__p_SWMgr, 
_swigt__p_SWCom, 
_swigt__p_RawLD4, 
_swigt__p_ListKey, 
_swigt__p_SWKey, 
_swigt__p_ConfigEntMap, 
_swigt__p_p_char, 
_swigt__p_RawLD, 
_swigt__p_TreeKey, 
_swigt__p_bool, 
_swigt__p_void, 
_swigt__p_SWFilterMgr, 
_swigt__p_SWLD, 
_swigt__p_SWTextDirection, 
_swigt__p_RawText, 
_swigt__p_f_char_p_void__void, 
_swigt__p_VerseKey, 
_swigt__p_ModMap, 
_swigt__p_string, 
_swigt__p_SectionMap, 
_swigt__p_SWDisplay, 
_swigt__p_AttributeTypeList, 
_swigt__p_SWText, 
_swigt__p_SWCompress, 
_swigt__p_LZSSCompress, 
_swigt__p_ZipCompress, 
_swigt__p_SW_POSITION, 
_swigt__p_SWModule, 
_swigt__p_zLD, 
_swigt__p_SWGenBook, 
_swigt__p_RawGenBook, 
_swigt__p_SWConfig, 
_swigt__p_LocaleMgr, 
_swigt__p_int, 
_swigt__p_SWTextMarkup, 
_swigt__p_OptionsList, 
_swigt__p_listTstring_t, 
_swigt__p_zText, 
_swigt__p_SWTextEncoding, 
_swigt__p_unsigned_long, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* vdecl subsection */
static zend_class_entry ce_swig_SWConfig;
static zend_class_entry* ptr_ce_swig_SWConfig=NULL;
static zend_class_entry ce_swig_SWMgr;
static zend_class_entry* ptr_ce_swig_SWMgr=NULL;
static zend_class_entry ce_swig_SWModule;
static zend_class_entry* ptr_ce_swig_SWModule=NULL;
static zend_class_entry ce_swig_SW_POSITION;
static zend_class_entry* ptr_ce_swig_SW_POSITION=NULL;
static zend_class_entry ce_swig_SWKey;
static zend_class_entry* ptr_ce_swig_SWKey=NULL;
static zend_class_entry ce_swig_VerseKey;
static zend_class_entry* ptr_ce_swig_VerseKey=NULL;
static zend_class_entry ce_swig_ListKey;
static zend_class_entry* ptr_ce_swig_ListKey=NULL;
static zend_class_entry ce_swig_TreeKey;
static zend_class_entry* ptr_ce_swig_TreeKey=NULL;
static zend_class_entry ce_swig_TreeKeyIdx;
static zend_class_entry* ptr_ce_swig_TreeKeyIdx=NULL;
static zend_class_entry ce_swig_LocaleMgr;
static zend_class_entry* ptr_ce_swig_LocaleMgr=NULL;
static zend_class_entry ce_swig_SWFilterMgr;
static zend_class_entry* ptr_ce_swig_SWFilterMgr=NULL;
static zend_class_entry ce_swig_SWText;
static zend_class_entry* ptr_ce_swig_SWText=NULL;
static zend_class_entry ce_swig_RawText;
static zend_class_entry* ptr_ce_swig_RawText=NULL;
static zend_class_entry ce_swig_zText;
static zend_class_entry* ptr_ce_swig_zText=NULL;
static zend_class_entry ce_swig_SWCom;
static zend_class_entry* ptr_ce_swig_SWCom=NULL;
static zend_class_entry ce_swig_RawCom;
static zend_class_entry* ptr_ce_swig_RawCom=NULL;
static zend_class_entry ce_swig_zCom;
static zend_class_entry* ptr_ce_swig_zCom=NULL;
static zend_class_entry ce_swig_SWGenBook;
static zend_class_entry* ptr_ce_swig_SWGenBook=NULL;
static zend_class_entry ce_swig_RawGenBook;
static zend_class_entry* ptr_ce_swig_RawGenBook=NULL;
static zend_class_entry ce_swig_SWLD;
static zend_class_entry* ptr_ce_swig_SWLD=NULL;
static zend_class_entry ce_swig_RawLD;
static zend_class_entry* ptr_ce_swig_RawLD=NULL;
static zend_class_entry ce_swig_RawLD4;
static zend_class_entry* ptr_ce_swig_RawLD4=NULL;
static zend_class_entry ce_swig_zLD;
static zend_class_entry* ptr_ce_swig_zLD=NULL;
static zend_class_entry ce_swig_SWCompress;
static zend_class_entry* ptr_ce_swig_SWCompress=NULL;
static zend_class_entry ce_swig_LZSSCompress;
static zend_class_entry* ptr_ce_swig_LZSSCompress=NULL;
static zend_class_entry ce_swig_ZipCompress;
static zend_class_entry* ptr_ce_swig_ZipCompress=NULL;
static int le_swig__p_SWLocale=0; // handle for 
static int le_swig__p_SWMgr=0; // handle for SWMgr
static int le_swig__p_SWCom=0; // handle for SWCom
static int le_swig__p_RawLD4=0; // handle for RawLD4
static int le_swig__p_ListKey=0; // handle for ListKey
static int le_swig__p_SWKey=0; // handle for SWKey
static int le_swig__p_ConfigEntMap=0; // handle for SWKey
static int le_swig__p_p_char=0; // handle for SWKey
static int le_swig__p_RawLD=0; // handle for RawLD
static int le_swig__p_TreeKey=0; // handle for TreeKey
static int le_swig__p_bool=0; // handle for TreeKey
static int le_swig__p_void=0; // handle for TreeKey
static int le_swig__p_SWFilterMgr=0; // handle for SWFilterMgr
static int le_swig__p_SWLD=0; // handle for SWLD
static int le_swig__p_SWTextDirection=0; // handle for SWLD
static int le_swig__p_RawText=0; // handle for RawText
static int le_swig__p_f_char_p_void__void=0; // handle for RawText
static int le_swig__p_VerseKey=0; // handle for VerseKey
static int le_swig__p_ModMap=0; // handle for VerseKey
static int le_swig__p_string=0; // handle for VerseKey
static int le_swig__p_SectionMap=0; // handle for VerseKey
static int le_swig__p_SWDisplay=0; // handle for VerseKey
static int le_swig__p_AttributeTypeList=0; // handle for VerseKey
static int le_swig__p_SWText=0; // handle for SWText
static int le_swig__p_SWCompress=0; // handle for SWCompress
static int le_swig__p_LZSSCompress=0; // handle for LZSSCompress
static int le_swig__p_ZipCompress=0; // handle for ZipCompress
static int le_swig__p_SW_POSITION=0; // handle for SW_POSITION
static int le_swig__p_SWModule=0; // handle for SWModule
static int le_swig__p_zLD=0; // handle for zLD
static int le_swig__p_SWGenBook=0; // handle for SWGenBook
static int le_swig__p_RawGenBook=0; // handle for RawGenBook
static int le_swig__p_SWConfig=0; // handle for SWConfig
static int le_swig__p_LocaleMgr=0; // handle for LocaleMgr
static int le_swig__p_int=0; // handle for LocaleMgr
static int le_swig__p_SWTextMarkup=0; // handle for LocaleMgr
static int le_swig__p_OptionsList=0; // handle for LocaleMgr
static int le_swig__p_listTstring_t=0; // handle for LocaleMgr
static int le_swig__p_zText=0; // handle for zText
static int le_swig__p_SWTextEncoding=0; // handle for zText
static int le_swig__p_unsigned_long=0; // handle for zText
/* end vdecl subsection */
/* wrapper section */
static int _wrap_SWConfig_filename_set(zend_property_reference *property_reference, pval *value) {
    SWConfig *arg1 ;
    string arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWConfig_filename_set. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    {
        string * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_string) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of SWConfig_filename_set. Expected %s", 2-argbase, SWIGTYPE_p_string->name);
        }
        arg2 = *argp;
    }
    if (arg1) (arg1)->filename = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_SWConfig_filename_get(zend_property_reference *property_reference) {
    SWConfig *arg1 ;
    string result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWConfig_filename_get. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    result =  ((arg1)->filename);
    
    {
        string * resultobj = new string((string &) result);
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_string, 0);
    }
    return _return_value;
}


static int _wrap_SWConfig_Sections_set(zend_property_reference *property_reference, pval *value) {
    SWConfig *arg1 ;
    SectionMap arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWConfig_Sections_set. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    {
        SectionMap * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_SectionMap) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of SWConfig_Sections_set. Expected %s", 2-argbase, SWIGTYPE_p_SectionMap->name);
        }
        arg2 = *argp;
    }
    if (arg1) (arg1)->Sections = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_SWConfig_Sections_get(zend_property_reference *property_reference) {
    SWConfig *arg1 ;
    SectionMap result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWConfig_Sections_get. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    result =  ((arg1)->Sections);
    
    {
        SectionMap * resultobj = new SectionMap((SectionMap &) result);
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_SectionMap, 0);
    }
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_SWConfig) {
    char *arg1 ;
    SWConfig *result;
    zval **args[2];
    int argbase=0 ;
    
    // NATIVE Constructor
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    result = (SWConfig *)new SWConfig((char const *)arg1);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWConfig, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWConfig);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_SWConfig(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    SWConfig *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_SWConfig TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "SWConfig resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_SWConfig) {
    SWConfig *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_SWConfig. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_SWConfig_Load) {
    SWConfig *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWConfig_Load. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    (arg1)->Load();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWConfig_Save) {
    SWConfig *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWConfig_Save. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    (arg1)->Save();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWConfig_set) {
    SWConfig *arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *arg4 ;
    zval **args[5];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 4) || (zend_get_parameters_array_ex(4-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWConfig_set. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    
    convert_to_string_ex(args[3-argbase]);
    arg4 = (char *) Z_STRVAL_PP(args[3-argbase]);
    
    SWConfig_set(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWConfig_get) {
    SWConfig *arg1 ;
    char *arg2 ;
    char *arg3 ;
    char *result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWConfig_get. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    result = (char *)SWConfig_get(arg1,(char const *)arg2,(char const *)arg3);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


// property handler for class SWConfig
static pval _wrap_propget_SWConfig(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWConfig(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWConfig(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Sections")==0) {
    *value=_wrap_SWConfig_Sections_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"filename")==0) {
    *value=_wrap_SWConfig_filename_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_SWConfig(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWConfig(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWConfig(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"filename")==0) {
    return _wrap_SWConfig_filename_set(property_reference, value);
  } else  if (strcmp(propname,"Sections")==0) {
    return _wrap_SWConfig_Sections_set(property_reference, value);
  } else  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_SWMgr_findConfig) {
    SWMgr *arg1 ;
    char *arg2 ;
    char **arg3 ;
    char **arg4 ;
    zval **args[5];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 4) || (zend_get_parameters_array_ex(4-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_findConfig. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    if(SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, SWIGTYPE_p_p_char) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_findConfig. Expected %s", 3-argbase, SWIGTYPE_p_p_char->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[3-argbase], (void **) &arg4, SWIGTYPE_p_p_char) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_findConfig. Expected %s", 4-argbase, SWIGTYPE_p_p_char->name);
    }
    
    (arg1)->findConfig(arg2,arg3,arg4);
    
    
}


static int _wrap_SWMgr_config_set(zend_property_reference *property_reference, pval *value) {
    SWMgr *arg1 ;
    SWConfig *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_config_set. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    if(SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_config_set. Expected %s", 2-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    if (arg1) (arg1)->config = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_SWMgr_config_get(zend_property_reference *property_reference) {
    SWMgr *arg1 ;
    SWConfig *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_config_get. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    result = (SWConfig *) ((arg1)->config);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWConfig, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWConfig);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
    return _return_value;
}


static int _wrap_SWMgr_sysconfig_set(zend_property_reference *property_reference, pval *value) {
    SWMgr *arg1 ;
    SWConfig *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_sysconfig_set. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    if(SWIG_ConvertPtr(*&value, (void **) &arg2, SWIGTYPE_p_SWConfig) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_sysconfig_set. Expected %s", 2-argbase, SWIGTYPE_p_SWConfig->name);
    }
    
    if (arg1) (arg1)->sysconfig = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_SWMgr_sysconfig_get(zend_property_reference *property_reference) {
    SWMgr *arg1 ;
    SWConfig *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_sysconfig_get. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    result = (SWConfig *) ((arg1)->sysconfig);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWConfig, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWConfig);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
    return _return_value;
}


static int _wrap_SWMgr_Modules_set(zend_property_reference *property_reference, pval *value) {
    SWMgr *arg1 ;
    ModMap arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_Modules_set. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    {
        ModMap * argp;
        if(SWIG_ConvertPtr(*&value, (void **) &argp, SWIGTYPE_p_ModMap) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of SWMgr_Modules_set. Expected %s", 2-argbase, SWIGTYPE_p_ModMap->name);
        }
        arg2 = *argp;
    }
    if (arg1) (arg1)->Modules = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_SWMgr_Modules_get(zend_property_reference *property_reference) {
    SWMgr *arg1 ;
    ModMap result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_Modules_get. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    result =  ((arg1)->Modules);
    
    {
        ModMap * resultobj = new ModMap((ModMap &) result);
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_ModMap, 0);
    }
    return _return_value;
}


static int _wrap_SWMgr_prefixPath_set(zend_property_reference *property_reference, pval *value) {
    SWMgr *arg1 ;
    char *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_prefixPath_set. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->prefixPath) delete [] arg1->prefixPath;
        arg1->prefixPath = (char *) (new char[strlen(arg2)+1]);
        strcpy((char *) arg1->prefixPath,arg2);
    }
    
    return SUCCESS;
}


static pval _wrap_SWMgr_prefixPath_get(zend_property_reference *property_reference) {
    SWMgr *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_prefixPath_get. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    result = (char *) ((arg1)->prefixPath);
    
    
    ZVAL_STRING(return_value,result, 1);
    
    return _return_value;
}


static int _wrap_SWMgr_configPath_set(zend_property_reference *property_reference, pval *value) {
    SWMgr *arg1 ;
    char *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_configPath_set. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    convert_to_string_ex(&value);
    arg2 = (char *) Z_STRVAL_PP(&value);
    
    {
        if (arg1->configPath) delete [] arg1->configPath;
        arg1->configPath = (char *) (new char[strlen(arg2)+1]);
        strcpy((char *) arg1->configPath,arg2);
    }
    
    return SUCCESS;
}


static pval _wrap_SWMgr_configPath_get(zend_property_reference *property_reference) {
    SWMgr *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_configPath_get. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    result = (char *) ((arg1)->configPath);
    
    
    ZVAL_STRING(return_value,result, 1);
    
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_SWMgr) {
    SWConfig *arg1 = 0 ;
    SWConfig *arg2 = 0 ;
    bool arg3 = true ;
    SWFilterMgr *arg4 = 0 ;
    SWMgr *result;
    zval **args[5];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(0-argbase) || arg_count>(4-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    if(arg_count > 0) {
        if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWConfig) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_SWMgr. Expected %s", 1-argbase, SWIGTYPE_p_SWConfig->name);
        }
        
    }
    if(arg_count > 1) {
        if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_SWConfig) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_SWMgr. Expected %s", 2-argbase, SWIGTYPE_p_SWConfig->name);
        }
        
    }
    if(arg_count > 2) {
        convert_to_long_ex(args[2-argbase]);
        arg3 = (bool) Z_LVAL_PP(args[2-argbase]);
        
    }
    if(arg_count > 3) {
        if(SWIG_ConvertPtr(*args[3-argbase], (void **) &arg4, SWIGTYPE_p_SWFilterMgr) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_SWMgr. Expected %s", 4-argbase, SWIGTYPE_p_SWFilterMgr->name);
        }
        
    }
    result = (SWMgr *)new SWMgr(arg1,arg2,arg3,arg4);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWMgr, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWMgr);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_SWMgr(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    SWMgr *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_SWMgr TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "SWMgr resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_SWMgr) {
    SWMgr *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_SWMgr. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_SWMgr_Load) {
    SWMgr *arg1 ;
    signed char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_Load. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    result = (signed char)(arg1)->Load();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWMgr_setGlobalOption) {
    SWMgr *arg1 ;
    char *arg2 ;
    char *arg3 ;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_setGlobalOption. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    (arg1)->setGlobalOption((char const *)arg2,(char const *)arg3);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWMgr_getGlobalOption) {
    SWMgr *arg1 ;
    char *arg2 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_getGlobalOption. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (char *)(arg1)->getGlobalOption((char const *)arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWMgr_getGlobalOptionTip) {
    SWMgr *arg1 ;
    char *arg2 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_getGlobalOptionTip. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (char *)(arg1)->getGlobalOptionTip((char const *)arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWMgr_getGlobalOptions) {
    SWMgr *arg1 ;
    OptionsList result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_getGlobalOptions. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    result = (arg1)->getGlobalOptions();
    
    {
        OptionsList * resultobj = new OptionsList((OptionsList &) result);
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_OptionsList, 0);
    }
}


ZEND_NAMED_FUNCTION(_wrap_SWMgr_getGlobalOptionValues) {
    SWMgr *arg1 ;
    char *arg2 ;
    OptionsList result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_getGlobalOptionValues. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (arg1)->getGlobalOptionValues((char const *)arg2);
    
    {
        OptionsList * resultobj = new OptionsList((OptionsList &) result);
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_OptionsList, 0);
    }
}


ZEND_NAMED_FUNCTION(_wrap_SWMgr_setCipherKey) {
    SWMgr *arg1 ;
    char *arg2 ;
    char *arg3 ;
    signed char result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_setCipherKey. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_string_ex(args[2-argbase]);
    arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
    
    result = (signed char)(arg1)->setCipherKey((char const *)arg2,(char const *)arg3);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWMgr_module) {
    SWMgr *arg1 ;
    char *arg2 ;
    SWModule *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWMgr_module. Expected %s", 1-argbase, SWIGTYPE_p_SWMgr->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (SWModule *)SWMgr_module(arg1,(char const *)arg2);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWModule, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWModule);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// property handler for class SWMgr
static pval _wrap_propget_SWMgr(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWMgr(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWMgr(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"prefixPath")==0) {
    *value=_wrap_SWMgr_prefixPath_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"configPath")==0) {
    *value=_wrap_SWMgr_configPath_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"Modules")==0) {
    *value=_wrap_SWMgr_Modules_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"config")==0) {
    *value=_wrap_SWMgr_config_get(property_reference);
    return SUCCESS;
  } else  if (strcmp(propname,"sysconfig")==0) {
    *value=_wrap_SWMgr_sysconfig_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_SWMgr(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWMgr(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWMgr(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"Modules")==0) {
    return _wrap_SWMgr_Modules_set(property_reference, value);
  } else  if (strcmp(propname,"config")==0) {
    return _wrap_SWMgr_config_set(property_reference, value);
  } else  if (strcmp(propname,"sysconfig")==0) {
    return _wrap_SWMgr_sysconfig_set(property_reference, value);
  } else  if (strcmp(propname,"prefixPath")==0) {
    return _wrap_SWMgr_prefixPath_set(property_reference, value);
  } else  if (strcmp(propname,"configPath")==0) {
    return _wrap_SWMgr_configPath_set(property_reference, value);
  } else  return FAILURE;
}

static int _wrap_SWModule_terminateSearch_set(zend_property_reference *property_reference, pval *value) {
    SWModule *arg1 ;
    bool arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_terminateSearch_set. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_long_ex(&value);
    arg2 = (bool) Z_LVAL_PP(&value);
    
    if (arg1) (arg1)->terminateSearch = arg2;
    
    
    return SUCCESS;
}


static pval _wrap_SWModule_terminateSearch_get(zend_property_reference *property_reference) {
    SWModule *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    zval _return_value;
    zval *return_value=&_return_value;
    
    
    if(SWIG_ConvertPtr(*&(property_reference->object), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_terminateSearch_get. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (bool) ((arg1)->terminateSearch);
    
    
    ZVAL_LONG(return_value,result);
    
    return _return_value;
}


ZEND_NAMED_FUNCTION(_wrap_new_SWModule) {
    char *arg1 = 0 ;
    char *arg2 = 0 ;
    SWDisplay *arg3 = 0 ;
    char *arg4 = 0 ;
    SWTextEncoding arg5 = ENC_UNKNOWN ;
    SWTextDirection arg6 = DIRECTION_LTR ;
    SWTextMarkup arg7 = FMT_UNKNOWN ;
    char *arg8 = 0 ;
    SWModule *result;
    zval **args[9];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(0-argbase) || arg_count>(8-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    if(arg_count > 0) {
        convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
        arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
        
    }
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, SWIGTYPE_p_SWDisplay) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_SWModule. Expected %s", 3-argbase, SWIGTYPE_p_SWDisplay->name);
        }
        
    }
    if(arg_count > 3) {
        convert_to_string_ex(args[3-argbase]);
        arg4 = (char *) Z_STRVAL_PP(args[3-argbase]);
        
    }
    if(arg_count > 4) {
        {
            SWTextEncoding * argp;
            if(SWIG_ConvertPtr(*args[4-argbase], (void **) &argp, SWIGTYPE_p_SWTextEncoding) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_SWModule. Expected %s", 5-argbase, SWIGTYPE_p_SWTextEncoding->name);
            }
            arg5 = *argp;
        }
    }
    if(arg_count > 5) {
        {
            SWTextDirection * argp;
            if(SWIG_ConvertPtr(*args[5-argbase], (void **) &argp, SWIGTYPE_p_SWTextDirection) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_SWModule. Expected %s", 6-argbase, SWIGTYPE_p_SWTextDirection->name);
            }
            arg6 = *argp;
        }
    }
    if(arg_count > 6) {
        {
            SWTextMarkup * argp;
            if(SWIG_ConvertPtr(*args[6-argbase], (void **) &argp, SWIGTYPE_p_SWTextMarkup) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_SWModule. Expected %s", 7-argbase, SWIGTYPE_p_SWTextMarkup->name);
            }
            arg7 = *argp;
        }
    }
    if(arg_count > 7) {
        convert_to_string_ex(args[7-argbase]);
        arg8 = (char *) Z_STRVAL_PP(args[7-argbase]);
        
    }
    result = (SWModule *)new SWModule((char const *)arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWModule, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWModule);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Error) {
    SWModule *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Error. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (unsigned char)(arg1)->Error();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_isUnicode) {
    SWModule *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_isUnicode. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (bool)((SWModule const *)arg1)->isUnicode();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_getConfig) {
    SWModule *arg1 ;
    ConfigEntMap *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_getConfig. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    {
        ConfigEntMap const &_result_ref = ((SWModule const *)arg1)->getConfig();
        result = (ConfigEntMap *) &_result_ref;
    }
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_ConfigEntMap, 0);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_getConfigEntry) {
    SWModule *arg1 ;
    char *arg2 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_getConfigEntry. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (char *)((SWModule const *)arg1)->getConfigEntry((char const *)arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_SetKey) {
    SWModule *arg1 ;
    SWKey *arg2 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_SetKey. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_SetKey. Expected %s", 2-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (unsigned char)(arg1)->SetKey((SWKey const *)arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Key) {
    SWModule *arg1 ;
    SWKey *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Key. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    {
        SWKey &_result_ref = ((SWModule const *)arg1)->Key();
        result = (SWKey *) &_result_ref;
    }
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWKey, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_CreateKey) {
    SWModule *arg1 ;
    SWKey *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_CreateKey. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (SWKey *)(arg1)->CreateKey();
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWKey, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_KeyText) {
    SWModule *arg1 ;
    char *arg2 = 0 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_KeyText. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    result = (char *)(arg1)->KeyText((char const *)arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Display) {
    SWModule *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Display. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (unsigned char)(arg1)->Display();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_nullPercent) {
    SWModule *arg1 ;
    char arg2 ;
    void *arg3 ;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_nullPercent. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char) *Z_STRVAL_PP(args[1-argbase]);
    
    
    if(SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, 0) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_nullPercent. Expected %s", 3-argbase, SWIGTYPE_p_void->name);
    }
    
    (arg1)->nullPercent(arg2,arg3);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Search) {
    SWModule *arg1 ;
    char *arg2 ;
    int arg3 = 0 ;
    int arg4 = 0 ;
    SWKey *arg5 = 0 ;
    bool *arg6 = 0 ;
    void (*arg7)(char,void *) = &SWModule::nullPercent ;
    void *arg8 = 0 ;
    ListKey *result;
    bool intr6 ;
    int force6 ;
    zval **args[9];
    int argbase=0 ;
    int arg_count;
    zval ** _saved[1] ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(2-argbase) || arg_count>(8-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Search. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    if(arg_count > 2) {
        convert_to_long_ex(args[2-argbase]);
        arg3 = (int) Z_LVAL_PP(args[2-argbase]);
        
    }
    if(arg_count > 3) {
        convert_to_long_ex(args[3-argbase]);
        arg4 = (int) Z_LVAL_PP(args[3-argbase]);
        
    }
    if(arg_count > 4) {
        if(SWIG_ConvertPtr(*args[4-argbase], (void **) &arg5, SWIGTYPE_p_SWKey) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of SWModule_Search. Expected %s", 5-argbase, SWIGTYPE_p_SWKey->name);
        }
        
    }
    if(arg_count > 5) {
        if(SWIG_ConvertPtr(*args[5-argbase], (void **) &arg6, SWIGTYPE_p_bool) < 0) {
            // So... we didn't get a ref or ptr, but can it be 
            // reasonably co-erced into what we were 
            // looking for a ref of or ptr to?
            if ((*args[5-argbase])->type==IS_STRING ||
            (*args[5-argbase])->type==IS_LONG ||
            (*args[5-argbase])->type==IS_DOUBLE) {
                convert_to_long_ex(args[5-argbase]);
                intr6 = (bool) (*args[5-argbase])->value.lval;
                arg6 = &intr6;
                // have to passback arg$arg too
                force6=1;
            }else {
                // wasn't a pre/ref/thing, OR anything like an int thing
                force6=0;
                zend_error(E_ERROR, "Type error in argument %d of SWModule_Search. Expected %s or at least something looking vaguely like a number hopefully passed by reference", 6-argbase, SWIGTYPE_p_bool->name);
            }
        }else force6=0;
        
    }
    if(arg_count > 6) {
        if(SWIG_ConvertPtr(*args[6-argbase], (void **) &arg7, SWIGTYPE_p_f_char_p_void__void) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of SWModule_Search. Expected %s", 7-argbase, SWIGTYPE_p_f_char_p_void__void->name);
        }
        
    }
    if(arg_count > 7) {
        if(SWIG_ConvertPtr(*args[7-argbase], (void **) &arg8, 0) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of SWModule_Search. Expected %s", 8-argbase, SWIGTYPE_p_void->name);
        }
        
    }
    _saved[0] = args[5-argbase];
    {
        ListKey &_result_ref = (arg1)->Search((char const *)arg2,arg3,arg4,arg5,arg6,arg7,arg8);
        result = (ListKey *) &_result_ref;
    }
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_ListKey, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_ListKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
    
    if (force6) {
        // pass back arg6 through params (_saved[0]) if we can
        if(! PZVAL_IS_REF(*_saved[0])) {
            zend_error(E_WARNING, "Parameter %d of SWModule_Search wasn't passed by reference",6-argbase);
        }else {
            ZVAL_LONG(*_saved[0],intr6);
        }
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_createSearchFramework) {
    SWModule *arg1 ;
    signed char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_createSearchFramework. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (signed char)(arg1)->createSearchFramework();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_hasSearchFramework) {
    SWModule *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_hasSearchFramework. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (bool)(arg1)->hasSearchFramework();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_isSearchOptimallySupported) {
    SWModule *arg1 ;
    char *arg2 ;
    int arg3 ;
    int arg4 ;
    SWKey *arg5 ;
    bool result;
    zval **args[6];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 5) || (zend_get_parameters_array_ex(5-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_isSearchOptimallySupported. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_long_ex(args[2-argbase]);
    arg3 = (int) Z_LVAL_PP(args[2-argbase]);
    
    
    convert_to_long_ex(args[3-argbase]);
    arg4 = (int) Z_LVAL_PP(args[3-argbase]);
    
    
    if(SWIG_ConvertPtr(*args[4-argbase], (void **) &arg5, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_isSearchOptimallySupported. Expected %s", 5-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (bool)(arg1)->isSearchOptimallySupported((char const *)arg2,arg3,arg4,arg5);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_next) {
    SWModule *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_next. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (bool)SWModule_next(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_prev) {
    SWModule *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_prev. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (bool)SWModule_prev(arg1);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_inc) {
    SWModule *arg1 ;
    int arg2 ;
    bool result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_inc. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    result = (bool)SWModule_inc(arg1,arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_dec) {
    SWModule *arg1 ;
    int arg2 ;
    bool result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_dec. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    result = (bool)SWModule_dec(arg1,arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_setPosition) {
    SWModule *arg1 ;
    SwigValueWrapper< SW_POSITION > arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_setPosition. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    {
        SW_POSITION * argp;
        if(SWIG_ConvertPtr(*args[1-argbase], (void **) &argp, SWIGTYPE_p_SW_POSITION) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of SWModule_setPosition. Expected %s", 2-argbase, SWIGTYPE_p_SW_POSITION->name);
        }
        arg2 = *argp;
    }
    SWModule_setPosition(arg1,arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_top) {
    SWModule *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_top. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    SWModule_top(arg1);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_bottom) {
    SWModule *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_bottom. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    SWModule_bottom(arg1);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_text) {
    SWModule *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_text. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (char *)SWModule_text(arg1);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_StripText) {
    SWModule *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_StripText. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (char *)SWModule_StripText(arg1);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_getRawEntry) {
    SWModule *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_getRawEntry. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (char *)(arg1)->getRawEntry();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_setSkipConsecutiveLinks) {
    SWModule *arg1 ;
    bool arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_setSkipConsecutiveLinks. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (bool) Z_LVAL_PP(args[1-argbase]);
    
    (arg1)->setSkipConsecutiveLinks(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_getSkipConsecutiveLinks) {
    SWModule *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_getSkipConsecutiveLinks. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (bool)(arg1)->getSkipConsecutiveLinks();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_getEntryAttributes) {
    SWModule *arg1 ;
    AttributeTypeList *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_getEntryAttributes. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    {
        AttributeTypeList &_result_ref = ((SWModule const *)arg1)->getEntryAttributes();
        result = (AttributeTypeList *) &_result_ref;
    }
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_AttributeTypeList, 0);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_processEntryAttributes) {
    SWModule *arg1 ;
    bool arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_processEntryAttributes. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (bool) Z_LVAL_PP(args[1-argbase]);
    
    ((SWModule const *)arg1)->processEntryAttributes(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_isProcessEntryAttributes) {
    SWModule *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_isProcessEntryAttributes. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (bool)((SWModule const *)arg1)->isProcessEntryAttributes();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Name) {
    SWModule *arg1 ;
    char *arg2 = 0 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Name. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    result = (char *)(arg1)->Name((char const *)arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Description) {
    SWModule *arg1 ;
    char *arg2 = 0 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Description. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    result = (char *)(arg1)->Description((char const *)arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Type) {
    SWModule *arg1 ;
    char *arg2 = 0 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Type. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    result = (char *)(arg1)->Type((char const *)arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Direction) {
    SWModule *arg1 ;
    signed char arg2 = -1 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Direction. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    if(arg_count > 1) {
        convert_to_long_ex(args[1-argbase]);
        arg2 = (signed char) Z_LVAL_PP(args[1-argbase]);
        
    }
    result = (unsigned char)(arg1)->Direction(arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Encoding) {
    SWModule *arg1 ;
    signed char arg2 = -1 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Encoding. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    if(arg_count > 1) {
        convert_to_long_ex(args[1-argbase]);
        arg2 = (signed char) Z_LVAL_PP(args[1-argbase]);
        
    }
    result = (unsigned char)(arg1)->Encoding(arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Markup) {
    SWModule *arg1 ;
    signed char arg2 = -1 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Markup. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    if(arg_count > 1) {
        convert_to_long_ex(args[1-argbase]);
        arg2 = (signed char) Z_LVAL_PP(args[1-argbase]);
        
    }
    result = (unsigned char)(arg1)->Markup(arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_Lang) {
    SWModule *arg1 ;
    char *arg2 = 0 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_Lang. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    result = (char *)(arg1)->Lang((char const *)arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_isWritable) {
    SWModule *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_isWritable. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    result = (bool)(arg1)->isWritable();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_createModule) {
    SWModule *arg1 ;
    char *arg2 ;
    signed char result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_createModule. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (signed char)(arg1)->createModule((char const *)arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_setEntry) {
    SWModule *arg1 ;
    char *arg2 ;
    long arg3 ;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_setEntry. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_long_ex(args[2-argbase]);
    arg3 = (long) Z_LVAL_PP(args[2-argbase]);
    
    (arg1)->setEntry((char const *)arg2,arg3);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_deleteEntry) {
    SWModule *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_deleteEntry. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    (arg1)->deleteEntry();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_write) {
    SWModule *arg1 ;
    char *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_write. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    SWModule_write(arg1,(char const *)arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWModule_writeLink) {
    SWModule *arg1 ;
    SWKey *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_writeLink. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWModule_writeLink. Expected %s", 2-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    SWModule_writeLink(arg1,(SWKey const *)arg2);
    
    
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_SWModule(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    SWModule *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_SWModule TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "SWModule resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_SWModule) {
    SWModule *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWModule) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_SWModule. Expected %s", 1-argbase, SWIGTYPE_p_SWModule->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


// property handler for class SWModule
static pval _wrap_propget_SWModule(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWModule(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWModule(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"terminateSearch")==0) {
    *value=_wrap_SWModule_terminateSearch_get(property_reference);
    return SUCCESS;
  } else  return FAILURE;
}

static int _wrap_propset_SWModule(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWModule(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWModule(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  if (strcmp(propname,"terminateSearch")==0) {
    return _wrap_SWModule_terminateSearch_set(property_reference, value);
  } else  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_SW_POSITION) {
    char arg1 ;
    SW_POSITION *result;
    zval **args[2];
    int argbase=0 ;
    
    // NATIVE Constructor
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char) *Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    result = (SW_POSITION *)new SW_POSITION(arg1);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SW_POSITION, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SW_POSITION);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_SW_POSITION(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    SW_POSITION *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_SW_POSITION TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "SW_POSITION resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_SW_POSITION) {
    SW_POSITION *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SW_POSITION) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_SW_POSITION. Expected %s", 1-argbase, SWIGTYPE_p_SW_POSITION->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


// property handler for class SW_POSITION
static pval _wrap_propget_SW_POSITION(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SW_POSITION(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SW_POSITION(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_SW_POSITION(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SW_POSITION(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SW_POSITION(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_SWKey) {
    char *arg1 = 0 ;
    SWKey *result;
    zval **args[2];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(0-argbase) || arg_count>(1-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    if(arg_count > 0) {
        convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
        arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
        
    }
    result = (SWKey *)new SWKey((char const *)arg1);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWKey, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_clone) {
    SWKey *arg1 ;
    SWKey *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_clone. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (SWKey *)((SWKey const *)arg1)->clone();
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWKey, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_Persist) {
    SWKey *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_Persist. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (unsigned char)((SWKey const *)arg1)->Persist();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_setPersist) {
    SWKey *arg1 ;
    signed char arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_setPersist. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (signed char) Z_LVAL_PP(args[1-argbase]);
    
    SWKey_setPersist(arg1,arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_Error) {
    SWKey *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_Error. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (unsigned char)(arg1)->Error();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_setText) {
    SWKey *arg1 ;
    char *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_setText. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    (arg1)->setText((char const *)arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_getText) {
    SWKey *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_getText. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (char *)((SWKey const *)arg1)->getText();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_getShortText) {
    SWKey *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_getShortText. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (char *)((SWKey const *)arg1)->getShortText();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_compare) {
    SWKey *arg1 ;
    SWKey *arg2 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_compare. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_compare. Expected %s", 2-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (int)(arg1)->compare((SWKey const &)*arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_equals) {
    SWKey *arg1 ;
    SWKey *arg2 ;
    bool result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_equals. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_equals. Expected %s", 2-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (bool)(arg1)->equals((SWKey const &)*arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_decrement) {
    SWKey *arg1 ;
    int arg2 = 1 ;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_decrement. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    if(arg_count > 1) {
        convert_to_long_ex(args[1-argbase]);
        arg2 = (int) Z_LVAL_PP(args[1-argbase]);
        
    }
    (arg1)->decrement(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_increment) {
    SWKey *arg1 ;
    int arg2 = 1 ;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_increment. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    if(arg_count > 1) {
        convert_to_long_ex(args[1-argbase]);
        arg2 = (int) Z_LVAL_PP(args[1-argbase]);
        
    }
    (arg1)->increment(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_Traversable) {
    SWKey *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_Traversable. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (unsigned char)(arg1)->Traversable();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_Index) {
    SWKey *arg1 ;
    long result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_Index. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (long)((SWKey const *)arg1)->Index();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_next) {
    SWKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_next. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    SWKey_next(arg1);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_prev) {
    SWKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_prev. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    SWKey_prev(arg1);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWKey_setKey) {
    SWKey *arg1 ;
    SWKey *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_setKey. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWKey_setKey. Expected %s", 2-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    SWKey_setKey(arg1,(SWKey const *)arg2);
    
    
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_SWKey(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    SWKey *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_SWKey TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "SWKey resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_SWKey) {
    SWKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_SWKey. Expected %s", 1-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


// property handler for class SWKey
static pval _wrap_propget_SWKey(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWKey(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWKey(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_SWKey(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWKey(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWKey(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_VerseKey) {
    char *arg1 = 0 ;
    VerseKey *result;
    zval **args[2];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(0-argbase) || arg_count>(1-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    if(arg_count > 0) {
        convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
        arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
        
    }
    result = (VerseKey *)new VerseKey((char const *)arg1);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_VerseKey, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_VerseKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_VerseKey(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    VerseKey *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_VerseKey TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "VerseKey resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_VerseKey) {
    VerseKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_VerseKey. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_clone) {
    VerseKey *arg1 ;
    SWKey *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_clone. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (SWKey *)((VerseKey const *)arg1)->clone();
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWKey, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_LowerBound) {
    VerseKey *arg1 ;
    VerseKey *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_LowerBound. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    {
        VerseKey &_result_ref = ((VerseKey const *)arg1)->LowerBound();
        result = (VerseKey *) &_result_ref;
    }
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_VerseKey, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_VerseKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_UpperBound) {
    VerseKey *arg1 ;
    VerseKey *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_UpperBound. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    {
        VerseKey &_result_ref = ((VerseKey const *)arg1)->UpperBound();
        result = (VerseKey *) &_result_ref;
    }
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_VerseKey, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_VerseKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_ClearBounds) {
    VerseKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_ClearBounds. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    (arg1)->ClearBounds();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_decrement) {
    VerseKey *arg1 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_decrement. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    (arg1)->decrement(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_increment) {
    VerseKey *arg1 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_increment. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    (arg1)->increment(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_Traversable) {
    VerseKey *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_Traversable. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (unsigned char)(arg1)->Traversable();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_getBookName) {
    VerseKey *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_getBookName. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (char *)((VerseKey const *)arg1)->getBookName();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_getBookAbbrev) {
    VerseKey *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_getBookAbbrev. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (char *)((VerseKey const *)arg1)->getBookAbbrev();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_Testament) {
    VerseKey *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_Testament. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (unsigned char)((VerseKey const *)arg1)->Testament();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_Book) {
    VerseKey *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_Book. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (unsigned char)((VerseKey const *)arg1)->Book();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_Chapter) {
    VerseKey *arg1 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_Chapter. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (int)((VerseKey const *)arg1)->Chapter();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_Verse) {
    VerseKey *arg1 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_Verse. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (int)((VerseKey const *)arg1)->Verse();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_Normalize) {
    VerseKey *arg1 ;
    char arg2 = 0 ;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_Normalize. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char) *Z_STRVAL_PP(args[1-argbase]);
        
    }
    (arg1)->Normalize(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_AutoNormalize) {
    VerseKey *arg1 ;
    char arg2 = MAXPOS(char) ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_AutoNormalize. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char) *Z_STRVAL_PP(args[1-argbase]);
        
    }
    result = (unsigned char)(arg1)->AutoNormalize(arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_Headings) {
    VerseKey *arg1 ;
    char arg2 = MAXPOS(char) ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_Headings. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char) *Z_STRVAL_PP(args[1-argbase]);
        
    }
    result = (unsigned char)(arg1)->Headings(arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_getOSISRef) {
    VerseKey *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_getOSISRef. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (char *)((VerseKey const *)arg1)->getOSISRef();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_compare) {
    VerseKey *arg1 ;
    SWKey *arg2 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_compare. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_compare. Expected %s", 2-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    result = (int)(arg1)->compare((SWKey const &)*arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey__compare) {
    VerseKey *arg1 ;
    VerseKey *arg2 ;
    int result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey__compare. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey__compare. Expected %s", 2-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (int)(arg1)->_compare((VerseKey const &)*arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_setLocale) {
    VerseKey *arg1 ;
    char *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_setLocale. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    (arg1)->setLocale((char const *)arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_VerseKey_getLocale) {
    VerseKey *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_VerseKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of VerseKey_getLocale. Expected %s", 1-argbase, SWIGTYPE_p_VerseKey->name);
    }
    
    result = (char *)((VerseKey const *)arg1)->getLocale();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


// property handler for class VerseKey
static pval _wrap_propget_VerseKey(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_VerseKey(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_VerseKey(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass VerseKey
  {
    // chain to base class
    if (_propget_SWKey(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_VerseKey(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_VerseKey(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_VerseKey(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass VerseKey
  {
    // chain to base class
    if (_propset_SWKey(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_ListKey) {
    char *arg1 = 0 ;
    ListKey *result;
    zval **args[2];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(0-argbase) || arg_count>(1-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    if(arg_count > 0) {
        convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
        arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
        
    }
    result = (ListKey *)new ListKey((char const *)arg1);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_ListKey, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_ListKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_copy_ListKey) {
    ListKey *arg1 ;
    ListKey *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of copy_ListKey. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    result = (ListKey *)new ListKey((ListKey const &)*arg1);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_ListKey, 1);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_ListKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_ListKey(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    ListKey *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_ListKey TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "ListKey resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_ListKey) {
    ListKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_ListKey. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_clone) {
    ListKey *arg1 ;
    SWKey *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_clone. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    result = (SWKey *)((ListKey const *)arg1)->clone();
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWKey, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_ClearList) {
    ListKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_ClearList. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    (arg1)->ClearList();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_Count) {
    ListKey *arg1 ;
    int result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_Count. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    result = (int)(arg1)->Count();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_Remove) {
    ListKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_Remove. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    (arg1)->Remove();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_SetToElement) {
    ListKey *arg1 ;
    int arg2 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_SetToElement. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    result = (unsigned char)ListKey_SetToElement(arg1,arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_GetElement) {
    ListKey *arg1 ;
    int arg2 = -1 ;
    SWKey *result;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_GetElement. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    if(arg_count > 1) {
        convert_to_long_ex(args[1-argbase]);
        arg2 = (int) Z_LVAL_PP(args[1-argbase]);
        
    }
    result = (SWKey *)(arg1)->GetElement(arg2);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWKey, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWKey);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_add) {
    ListKey *arg1 ;
    SWKey *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_add. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_SWKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_add. Expected %s", 2-argbase, SWIGTYPE_p_SWKey->name);
    }
    
    (arg1)->add((SWKey const &)*arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_copyFrom) {
    ListKey *arg1 ;
    ListKey *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_copyFrom. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_copyFrom. Expected %s", 2-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    (arg1)->copyFrom((ListKey const &)*arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_setPosition) {
    ListKey *arg1 ;
    SwigValueWrapper< SW_POSITION > arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_setPosition. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    {
        SW_POSITION * argp;
        if(SWIG_ConvertPtr(*args[1-argbase], (void **) &argp, SWIGTYPE_p_SW_POSITION) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of ListKey_setPosition. Expected %s", 2-argbase, SWIGTYPE_p_SW_POSITION->name);
        }
        arg2 = *argp;
    }
    (arg1)->setPosition(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_decrement) {
    ListKey *arg1 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_decrement. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    (arg1)->decrement(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_increment) {
    ListKey *arg1 ;
    int arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_increment. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (int) Z_LVAL_PP(args[1-argbase]);
    
    (arg1)->increment(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_Traversable) {
    ListKey *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_Traversable. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    result = (unsigned char)(arg1)->Traversable();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_ListKey_Index) {
    ListKey *arg1 ;
    long result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ListKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ListKey_Index. Expected %s", 1-argbase, SWIGTYPE_p_ListKey->name);
    }
    
    result = (long)((ListKey const *)arg1)->Index();
    
    
    ZVAL_LONG(return_value,result);
    
}


// property handler for class ListKey
static pval _wrap_propget_ListKey(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_ListKey(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_ListKey(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass ListKey
  {
    // chain to base class
    if (_propget_SWKey(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_ListKey(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_ListKey(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_ListKey(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass ListKey
  {
    // chain to base class
    if (_propset_SWKey(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_TreeKey_getLocalName) {
    TreeKey *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_getLocalName. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (char *)(arg1)->getLocalName();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_setLocalName) {
    TreeKey *arg1 ;
    char *arg2 ;
    char *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_setLocalName. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (char *)(arg1)->setLocalName((char const *)arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_getUserData) {
    TreeKey *arg1 ;
    int *arg2 = 0 ;
    char *result;
    int intr2 ;
    int force2 ;
    zval **args[3];
    int argbase=0 ;
    int arg_count;
    zval ** _saved[1] ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(2-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_getUserData. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    if(arg_count > 1) {
        if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_int) < 0) {
            // So... we didn't get a ref or ptr, but can it be 
            // reasonably co-erced into what we were 
            // looking for a ref of or ptr to?
            if ((*args[1-argbase])->type==IS_STRING ||
            (*args[1-argbase])->type==IS_LONG ||
            (*args[1-argbase])->type==IS_DOUBLE) {
                convert_to_long_ex(args[1-argbase]);
                intr2 = (int) (*args[1-argbase])->value.lval;
                arg2 = &intr2;
                // have to passback arg$arg too
                force2=1;
            }else {
                // wasn't a pre/ref/thing, OR anything like an int thing
                force2=0;
                zend_error(E_ERROR, "Type error in argument %d of TreeKey_getUserData. Expected %s or at least something looking vaguely like a number hopefully passed by reference", 2-argbase, SWIGTYPE_p_int->name);
            }
        }else force2=0;
        
    }
    _saved[0] = args[1-argbase];
    result = (char *)(arg1)->getUserData(arg2);
    
    
    ZVAL_STRING(return_value,result, 1);
    
    
    if (force2) {
        // pass back arg2 through params (_saved[0]) if we can
        if(! PZVAL_IS_REF(*_saved[0])) {
            zend_error(E_WARNING, "Parameter %d of TreeKey_getUserData wasn't passed by reference",2-argbase);
        }else {
            ZVAL_LONG(*_saved[0],intr2);
        }
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_setUserData) {
    TreeKey *arg1 ;
    char *arg2 ;
    int arg3 = 0 ;
    zval **args[4];
    int argbase=0 ;
    int arg_count;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(2-argbase) || arg_count>(3-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_setUserData. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    if(arg_count > 2) {
        convert_to_long_ex(args[2-argbase]);
        arg3 = (int) Z_LVAL_PP(args[2-argbase]);
        
    }
    (arg1)->setUserData((char const *)arg2,arg3);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_getFullName) {
    TreeKey *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_getFullName. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (char *)((TreeKey const *)arg1)->getFullName();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_root) {
    TreeKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_root. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    (arg1)->root();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_parent) {
    TreeKey *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_parent. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (bool)(arg1)->parent();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_firstChild) {
    TreeKey *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_firstChild. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (bool)(arg1)->firstChild();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_nextSibling) {
    TreeKey *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_nextSibling. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (bool)(arg1)->nextSibling();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_previousSibling) {
    TreeKey *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_previousSibling. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (bool)(arg1)->previousSibling();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_hasChildren) {
    TreeKey *arg1 ;
    bool result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_hasChildren. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (bool)(arg1)->hasChildren();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_append) {
    TreeKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_append. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    (arg1)->append();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_appendChild) {
    TreeKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_appendChild. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    (arg1)->appendChild();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_insertBefore) {
    TreeKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_insertBefore. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    (arg1)->insertBefore();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_remove) {
    TreeKey *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_remove. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    (arg1)->remove();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_setOffset) {
    TreeKey *arg1 ;
    unsigned long arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_setOffset. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    
    convert_to_long_ex(args[1-argbase]);
    arg2 = (unsigned long) Z_LVAL_PP(args[1-argbase]);
    
    (arg1)->setOffset(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_getOffset) {
    TreeKey *arg1 ;
    unsigned long result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_getOffset. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (unsigned long)((TreeKey const *)arg1)->getOffset();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_setPosition) {
    TreeKey *arg1 ;
    SwigValueWrapper< SW_POSITION > arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_setPosition. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    {
        SW_POSITION * argp;
        if(SWIG_ConvertPtr(*args[1-argbase], (void **) &argp, SWIGTYPE_p_SW_POSITION) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of TreeKey_setPosition. Expected %s", 2-argbase, SWIGTYPE_p_SW_POSITION->name);
        }
        arg2 = *argp;
    }
    (arg1)->setPosition(arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_Traversable) {
    TreeKey *arg1 ;
    unsigned char result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_Traversable. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (unsigned char)(arg1)->Traversable();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_TreeKey_Index) {
    TreeKey *arg1 ;
    long result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_TreeKey) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of TreeKey_Index. Expected %s", 1-argbase, SWIGTYPE_p_TreeKey->name);
    }
    
    result = (long)((TreeKey const *)arg1)->Index();
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_new_TreeKey) {
    zend_error(E_ERROR,"Cannot create swig object type: TreeKey as the underlying object is abstract");
}





// property handler for class TreeKey
static pval _wrap_propget_TreeKey(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_TreeKey(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_TreeKey(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass TreeKey
  {
    // chain to base class
    if (_propget_SWKey(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_TreeKey(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_TreeKey(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_TreeKey(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass TreeKey
  {
    // chain to base class
    if (_propset_SWKey(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_TreeKeyIdx) {
    zend_error(E_ERROR,"Cannot create swig object type: TreeKeyIdx as the underlying object is abstract");
}





// property handler for class TreeKeyIdx
static pval _wrap_propget_TreeKeyIdx(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_TreeKeyIdx(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_TreeKeyIdx(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass TreeKeyIdx
  {
    // chain to base class
    if (_propget_TreeKey(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_TreeKeyIdx(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_TreeKeyIdx(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_TreeKeyIdx(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass TreeKeyIdx
  {
    // chain to base class
    if (_propset_TreeKey(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_LocaleMgr) {
    char *arg1 = 0 ;
    LocaleMgr *result;
    zval **args[2];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(0-argbase) || arg_count>(1-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    if(arg_count > 0) {
        convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
        arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
        
    }
    result = (LocaleMgr *)new LocaleMgr((char const *)arg1);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LocaleMgr, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LocaleMgr);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_LocaleMgr(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LocaleMgr *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LocaleMgr TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LocaleMgr resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LocaleMgr) {
    LocaleMgr *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LocaleMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_LocaleMgr. Expected %s", 1-argbase, SWIGTYPE_p_LocaleMgr->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_LocaleMgr_getLocale) {
    LocaleMgr *arg1 ;
    char *arg2 ;
    SWLocale *result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LocaleMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of LocaleMgr_getLocale. Expected %s", 1-argbase, SWIGTYPE_p_LocaleMgr->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (SWLocale *)(arg1)->getLocale((char const *)arg2);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWLocale, 0);
    
}


ZEND_NAMED_FUNCTION(_wrap_LocaleMgr_getAvailableLocales) {
    LocaleMgr *arg1 ;
    list<string > result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LocaleMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of LocaleMgr_getAvailableLocales. Expected %s", 1-argbase, SWIGTYPE_p_LocaleMgr->name);
    }
    
    result = (arg1)->getAvailableLocales();
    
    {
        list<string > * resultobj = new list<string >((list<string > &) result);
        SWIG_SetPointerZval(return_value, (void *)resultobj, SWIGTYPE_p_listTstring_t, 0);
    }
}


ZEND_NAMED_FUNCTION(_wrap_LocaleMgr_getDefaultLocaleName) {
    LocaleMgr *arg1 ;
    char *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LocaleMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of LocaleMgr_getDefaultLocaleName. Expected %s", 1-argbase, SWIGTYPE_p_LocaleMgr->name);
    }
    
    result = (char *)(arg1)->getDefaultLocaleName();
    
    
    ZVAL_STRING(return_value,result, 1);
    
}


ZEND_NAMED_FUNCTION(_wrap_LocaleMgr_setDefaultLocaleName) {
    LocaleMgr *arg1 ;
    char *arg2 ;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LocaleMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of LocaleMgr_setDefaultLocaleName. Expected %s", 1-argbase, SWIGTYPE_p_LocaleMgr->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    (arg1)->setDefaultLocaleName((char const *)arg2);
    
    
}


ZEND_NAMED_FUNCTION(_wrap_LocaleMgr_systemLocaleMgr) {
    LocaleMgr *arg1 ;
    LocaleMgr *result;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LocaleMgr) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of LocaleMgr_systemLocaleMgr. Expected %s", 1-argbase, SWIGTYPE_p_LocaleMgr->name);
    }
    
    result = (LocaleMgr *)LocaleMgr_systemLocaleMgr(arg1);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LocaleMgr, 0);
    
    // Wrap this return value
    {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LocaleMgr);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// property handler for class LocaleMgr
static pval _wrap_propget_LocaleMgr(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LocaleMgr(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_LocaleMgr(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_LocaleMgr(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LocaleMgr(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_LocaleMgr(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_SWFilterMgr) {
    zend_error(E_ERROR,"Cannot create swig object type: SWFilterMgr as the underlying object is abstract");
}





// property handler for class SWFilterMgr
static pval _wrap_propget_SWFilterMgr(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWFilterMgr(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWFilterMgr(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_SWFilterMgr(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWFilterMgr(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWFilterMgr(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_SWText) {
    char *arg1 = 0 ;
    char *arg2 = 0 ;
    SWDisplay *arg3 = 0 ;
    SWTextEncoding arg4 = ENC_UNKNOWN ;
    SWTextDirection arg5 = DIRECTION_LTR ;
    SWTextMarkup arg6 = FMT_UNKNOWN ;
    char *arg7 = 0 ;
    SWText *result;
    zval **args[8];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(0-argbase) || arg_count>(7-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    if(arg_count > 0) {
        convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
        arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
        
    }
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, SWIGTYPE_p_SWDisplay) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_SWText. Expected %s", 3-argbase, SWIGTYPE_p_SWDisplay->name);
        }
        
    }
    if(arg_count > 3) {
        {
            SWTextEncoding * argp;
            if(SWIG_ConvertPtr(*args[3-argbase], (void **) &argp, SWIGTYPE_p_SWTextEncoding) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_SWText. Expected %s", 4-argbase, SWIGTYPE_p_SWTextEncoding->name);
            }
            arg4 = *argp;
        }
    }
    if(arg_count > 4) {
        {
            SWTextDirection * argp;
            if(SWIG_ConvertPtr(*args[4-argbase], (void **) &argp, SWIGTYPE_p_SWTextDirection) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_SWText. Expected %s", 5-argbase, SWIGTYPE_p_SWTextDirection->name);
            }
            arg5 = *argp;
        }
    }
    if(arg_count > 5) {
        {
            SWTextMarkup * argp;
            if(SWIG_ConvertPtr(*args[5-argbase], (void **) &argp, SWIGTYPE_p_SWTextMarkup) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_SWText. Expected %s", 6-argbase, SWIGTYPE_p_SWTextMarkup->name);
            }
            arg6 = *argp;
        }
    }
    if(arg_count > 6) {
        convert_to_string_ex(args[6-argbase]);
        arg7 = (char *) Z_STRVAL_PP(args[6-argbase]);
        
    }
    result = (SWText *)new SWText((char const *)arg1,(char const *)arg2,arg3,arg4,arg5,arg6,(char const *)arg7);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWText, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWText);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_SWText(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    SWText *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_SWText TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "SWText resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_SWText) {
    SWText *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWText) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_SWText. Expected %s", 1-argbase, SWIGTYPE_p_SWText->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


// property handler for class SWText
static pval _wrap_propget_SWText(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWText(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWText(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass SWText
  {
    // chain to base class
    if (_propget_SWModule(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_SWText(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWText(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWText(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass SWText
  {
    // chain to base class
    if (_propset_SWModule(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_RawText) {
    char *arg1 ;
    char *arg2 = 0 ;
    char *arg3 = 0 ;
    SWDisplay *arg4 = 0 ;
    SWTextEncoding arg5 = ENC_UNKNOWN ;
    SWTextDirection arg6 = DIRECTION_LTR ;
    SWTextMarkup arg7 = FMT_UNKNOWN ;
    char *arg8 = 0 ;
    RawText *result;
    zval **args[9];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(8-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        convert_to_string_ex(args[2-argbase]);
        arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
        
    }
    if(arg_count > 3) {
        if(SWIG_ConvertPtr(*args[3-argbase], (void **) &arg4, SWIGTYPE_p_SWDisplay) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_RawText. Expected %s", 4-argbase, SWIGTYPE_p_SWDisplay->name);
        }
        
    }
    if(arg_count > 4) {
        {
            SWTextEncoding * argp;
            if(SWIG_ConvertPtr(*args[4-argbase], (void **) &argp, SWIGTYPE_p_SWTextEncoding) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawText. Expected %s", 5-argbase, SWIGTYPE_p_SWTextEncoding->name);
            }
            arg5 = *argp;
        }
    }
    if(arg_count > 5) {
        {
            SWTextDirection * argp;
            if(SWIG_ConvertPtr(*args[5-argbase], (void **) &argp, SWIGTYPE_p_SWTextDirection) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawText. Expected %s", 6-argbase, SWIGTYPE_p_SWTextDirection->name);
            }
            arg6 = *argp;
        }
    }
    if(arg_count > 6) {
        {
            SWTextMarkup * argp;
            if(SWIG_ConvertPtr(*args[6-argbase], (void **) &argp, SWIGTYPE_p_SWTextMarkup) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawText. Expected %s", 7-argbase, SWIGTYPE_p_SWTextMarkup->name);
            }
            arg7 = *argp;
        }
    }
    if(arg_count > 7) {
        convert_to_string_ex(args[7-argbase]);
        arg8 = (char *) Z_STRVAL_PP(args[7-argbase]);
        
    }
    result = (RawText *)new RawText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_RawText, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_RawText);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


ZEND_NAMED_FUNCTION(_wrap_RawText_createModule) {
    RawText *arg1 ;
    char *arg2 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_RawText) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of RawText_createModule. Expected %s", 1-argbase, SWIGTYPE_p_RawText->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (unsigned char)(arg1)->createModule((char const *)arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_RawText(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    RawText *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_RawText TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "RawText resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_RawText) {
    RawText *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_RawText) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_RawText. Expected %s", 1-argbase, SWIGTYPE_p_RawText->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


// property handler for class RawText
static pval _wrap_propget_RawText(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_RawText(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_RawText(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawText
  {
    // chain to base class
    if (_propget_SWText(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_RawText(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_RawText(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_RawText(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawText
  {
    // chain to base class
    if (_propset_SWText(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_zText) {
    char *arg1 ;
    char *arg2 = 0 ;
    char *arg3 = 0 ;
    int arg4 = CHAPTERBLOCKS ;
    SWCompress *arg5 = 0 ;
    SWDisplay *arg6 = 0 ;
    SWTextEncoding arg7 = ENC_UNKNOWN ;
    SWTextDirection arg8 = DIRECTION_LTR ;
    SWTextMarkup arg9 = FMT_UNKNOWN ;
    char *arg10 = 0 ;
    zText *result;
    zval **args[11];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(10-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        convert_to_string_ex(args[2-argbase]);
        arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
        
    }
    if(arg_count > 3) {
        convert_to_long_ex(args[3-argbase]);
        arg4 = (int) Z_LVAL_PP(args[3-argbase]);
        
    }
    if(arg_count > 4) {
        if(SWIG_ConvertPtr(*args[4-argbase], (void **) &arg5, SWIGTYPE_p_SWCompress) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_zText. Expected %s", 5-argbase, SWIGTYPE_p_SWCompress->name);
        }
        
    }
    if(arg_count > 5) {
        if(SWIG_ConvertPtr(*args[5-argbase], (void **) &arg6, SWIGTYPE_p_SWDisplay) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_zText. Expected %s", 6-argbase, SWIGTYPE_p_SWDisplay->name);
        }
        
    }
    if(arg_count > 6) {
        {
            SWTextEncoding * argp;
            if(SWIG_ConvertPtr(*args[6-argbase], (void **) &argp, SWIGTYPE_p_SWTextEncoding) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_zText. Expected %s", 7-argbase, SWIGTYPE_p_SWTextEncoding->name);
            }
            arg7 = *argp;
        }
    }
    if(arg_count > 7) {
        {
            SWTextDirection * argp;
            if(SWIG_ConvertPtr(*args[7-argbase], (void **) &argp, SWIGTYPE_p_SWTextDirection) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_zText. Expected %s", 8-argbase, SWIGTYPE_p_SWTextDirection->name);
            }
            arg8 = *argp;
        }
    }
    if(arg_count > 8) {
        {
            SWTextMarkup * argp;
            if(SWIG_ConvertPtr(*args[8-argbase], (void **) &argp, SWIGTYPE_p_SWTextMarkup) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_zText. Expected %s", 9-argbase, SWIGTYPE_p_SWTextMarkup->name);
            }
            arg9 = *argp;
        }
    }
    if(arg_count > 9) {
        convert_to_string_ex(args[9-argbase]);
        arg10 = (char *) Z_STRVAL_PP(args[9-argbase]);
        
    }
    result = (zText *)new zText((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,(char const *)arg10);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_zText, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_zText);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_zText(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    zText *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_zText TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "zText resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_zText) {
    zText *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_zText) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_zText. Expected %s", 1-argbase, SWIGTYPE_p_zText->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_zText_createModule) {
    zText *arg1 ;
    char *arg2 ;
    int arg3 ;
    unsigned char result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_zText) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of zText_createModule. Expected %s", 1-argbase, SWIGTYPE_p_zText->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_long_ex(args[2-argbase]);
    arg3 = (int) Z_LVAL_PP(args[2-argbase]);
    
    result = (unsigned char)(arg1)->createModule((char const *)arg2,arg3);
    
    
    ZVAL_LONG(return_value,result);
    
}


// property handler for class zText
static pval _wrap_propget_zText(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_zText(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_zText(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass zText
  {
    // chain to base class
    if (_propget_SWText(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_zText(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_zText(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_zText(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass zText
  {
    // chain to base class
    if (_propset_SWText(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_SWCom) {
    zend_error(E_ERROR,"Cannot create swig object type: SWCom as the underlying object is abstract");
}





// property handler for class SWCom
static pval _wrap_propget_SWCom(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWCom(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWCom(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass SWCom
  {
    // chain to base class
    if (_propget_SWModule(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_SWCom(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWCom(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWCom(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass SWCom
  {
    // chain to base class
    if (_propset_SWModule(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_RawCom) {
    zend_error(E_ERROR,"Cannot create swig object type: RawCom as the underlying object is abstract");
}





// property handler for class RawCom
static pval _wrap_propget_RawCom(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_RawCom(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_RawCom(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawCom
  {
    // chain to base class
    if (_propget_SWCom(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_RawCom(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_RawCom(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_RawCom(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawCom
  {
    // chain to base class
    if (_propset_SWCom(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_zCom) {
    zend_error(E_ERROR,"Cannot create swig object type: zCom as the underlying object is abstract");
}





// property handler for class zCom
static pval _wrap_propget_zCom(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_zCom(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_zCom(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass zCom
  {
    // chain to base class
    if (_propget_SWCom(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_zCom(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_zCom(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_zCom(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass zCom
  {
    // chain to base class
    if (_propset_SWCom(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_SWGenBook) {
    zend_error(E_ERROR,"Cannot create swig object type: SWGenBook as the underlying object is abstract");
}





// property handler for class SWGenBook
static pval _wrap_propget_SWGenBook(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWGenBook(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWGenBook(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass SWGenBook
  {
    // chain to base class
    if (_propget_SWModule(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_SWGenBook(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWGenBook(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWGenBook(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass SWGenBook
  {
    // chain to base class
    if (_propset_SWModule(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_RawGenBook) {
    char *arg1 ;
    char *arg2 = 0 ;
    char *arg3 = 0 ;
    SWDisplay *arg4 = 0 ;
    SWTextEncoding arg5 = ENC_UNKNOWN ;
    SWTextDirection arg6 = DIRECTION_LTR ;
    SWTextMarkup arg7 = FMT_UNKNOWN ;
    char *arg8 = 0 ;
    RawGenBook *result;
    zval **args[9];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(8-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        convert_to_string_ex(args[2-argbase]);
        arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
        
    }
    if(arg_count > 3) {
        if(SWIG_ConvertPtr(*args[3-argbase], (void **) &arg4, SWIGTYPE_p_SWDisplay) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_RawGenBook. Expected %s", 4-argbase, SWIGTYPE_p_SWDisplay->name);
        }
        
    }
    if(arg_count > 4) {
        {
            SWTextEncoding * argp;
            if(SWIG_ConvertPtr(*args[4-argbase], (void **) &argp, SWIGTYPE_p_SWTextEncoding) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawGenBook. Expected %s", 5-argbase, SWIGTYPE_p_SWTextEncoding->name);
            }
            arg5 = *argp;
        }
    }
    if(arg_count > 5) {
        {
            SWTextDirection * argp;
            if(SWIG_ConvertPtr(*args[5-argbase], (void **) &argp, SWIGTYPE_p_SWTextDirection) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawGenBook. Expected %s", 6-argbase, SWIGTYPE_p_SWTextDirection->name);
            }
            arg6 = *argp;
        }
    }
    if(arg_count > 6) {
        {
            SWTextMarkup * argp;
            if(SWIG_ConvertPtr(*args[6-argbase], (void **) &argp, SWIGTYPE_p_SWTextMarkup) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawGenBook. Expected %s", 7-argbase, SWIGTYPE_p_SWTextMarkup->name);
            }
            arg7 = *argp;
        }
    }
    if(arg_count > 7) {
        convert_to_string_ex(args[7-argbase]);
        arg8 = (char *) Z_STRVAL_PP(args[7-argbase]);
        
    }
    result = (RawGenBook *)new RawGenBook((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_RawGenBook, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_RawGenBook);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_RawGenBook(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    RawGenBook *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_RawGenBook TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "RawGenBook resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_RawGenBook) {
    RawGenBook *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_RawGenBook) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_RawGenBook. Expected %s", 1-argbase, SWIGTYPE_p_RawGenBook->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_RawGenBook_createModule) {
    RawGenBook *arg1 ;
    char *arg2 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_RawGenBook) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of RawGenBook_createModule. Expected %s", 1-argbase, SWIGTYPE_p_RawGenBook->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (unsigned char)(arg1)->createModule((char const *)arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


// property handler for class RawGenBook
static pval _wrap_propget_RawGenBook(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_RawGenBook(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_RawGenBook(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawGenBook
  {
    // chain to base class
    if (_propget_SWGenBook(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_RawGenBook(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_RawGenBook(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_RawGenBook(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawGenBook
  {
    // chain to base class
    if (_propset_SWGenBook(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_SWLD) {
    char *arg1 = 0 ;
    char *arg2 = 0 ;
    SWDisplay *arg3 = 0 ;
    SWTextEncoding arg4 = ENC_UNKNOWN ;
    SWTextDirection arg5 = DIRECTION_LTR ;
    SWTextMarkup arg6 = FMT_UNKNOWN ;
    char *arg7 = 0 ;
    SWLD *result;
    zval **args[8];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(0-argbase) || arg_count>(7-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    if(arg_count > 0) {
        convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
        arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
        
    }
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, SWIGTYPE_p_SWDisplay) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_SWLD. Expected %s", 3-argbase, SWIGTYPE_p_SWDisplay->name);
        }
        
    }
    if(arg_count > 3) {
        {
            SWTextEncoding * argp;
            if(SWIG_ConvertPtr(*args[3-argbase], (void **) &argp, SWIGTYPE_p_SWTextEncoding) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_SWLD. Expected %s", 4-argbase, SWIGTYPE_p_SWTextEncoding->name);
            }
            arg4 = *argp;
        }
    }
    if(arg_count > 4) {
        {
            SWTextDirection * argp;
            if(SWIG_ConvertPtr(*args[4-argbase], (void **) &argp, SWIGTYPE_p_SWTextDirection) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_SWLD. Expected %s", 5-argbase, SWIGTYPE_p_SWTextDirection->name);
            }
            arg5 = *argp;
        }
    }
    if(arg_count > 5) {
        {
            SWTextMarkup * argp;
            if(SWIG_ConvertPtr(*args[5-argbase], (void **) &argp, SWIGTYPE_p_SWTextMarkup) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_SWLD. Expected %s", 6-argbase, SWIGTYPE_p_SWTextMarkup->name);
            }
            arg6 = *argp;
        }
    }
    if(arg_count > 6) {
        convert_to_string_ex(args[6-argbase]);
        arg7 = (char *) Z_STRVAL_PP(args[6-argbase]);
        
    }
    result = (SWLD *)new SWLD((char const *)arg1,(char const *)arg2,arg3,arg4,arg5,arg6,(char const *)arg7);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWLD, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWLD);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_SWLD(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    SWLD *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_SWLD TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "SWLD resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_SWLD) {
    SWLD *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWLD) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_SWLD. Expected %s", 1-argbase, SWIGTYPE_p_SWLD->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


// property handler for class SWLD
static pval _wrap_propget_SWLD(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWLD(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWLD(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass SWLD
  {
    // chain to base class
    if (_propget_SWModule(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_SWLD(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWLD(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWLD(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass SWLD
  {
    // chain to base class
    if (_propset_SWModule(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_RawLD) {
    char *arg1 ;
    char *arg2 = 0 ;
    char *arg3 = 0 ;
    SWDisplay *arg4 = 0 ;
    SWTextEncoding arg5 = ENC_UNKNOWN ;
    SWTextDirection arg6 = DIRECTION_LTR ;
    SWTextMarkup arg7 = FMT_UNKNOWN ;
    char *arg8 = 0 ;
    RawLD *result;
    zval **args[9];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(8-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        convert_to_string_ex(args[2-argbase]);
        arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
        
    }
    if(arg_count > 3) {
        if(SWIG_ConvertPtr(*args[3-argbase], (void **) &arg4, SWIGTYPE_p_SWDisplay) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_RawLD. Expected %s", 4-argbase, SWIGTYPE_p_SWDisplay->name);
        }
        
    }
    if(arg_count > 4) {
        {
            SWTextEncoding * argp;
            if(SWIG_ConvertPtr(*args[4-argbase], (void **) &argp, SWIGTYPE_p_SWTextEncoding) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawLD. Expected %s", 5-argbase, SWIGTYPE_p_SWTextEncoding->name);
            }
            arg5 = *argp;
        }
    }
    if(arg_count > 5) {
        {
            SWTextDirection * argp;
            if(SWIG_ConvertPtr(*args[5-argbase], (void **) &argp, SWIGTYPE_p_SWTextDirection) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawLD. Expected %s", 6-argbase, SWIGTYPE_p_SWTextDirection->name);
            }
            arg6 = *argp;
        }
    }
    if(arg_count > 6) {
        {
            SWTextMarkup * argp;
            if(SWIG_ConvertPtr(*args[6-argbase], (void **) &argp, SWIGTYPE_p_SWTextMarkup) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawLD. Expected %s", 7-argbase, SWIGTYPE_p_SWTextMarkup->name);
            }
            arg7 = *argp;
        }
    }
    if(arg_count > 7) {
        convert_to_string_ex(args[7-argbase]);
        arg8 = (char *) Z_STRVAL_PP(args[7-argbase]);
        
    }
    result = (RawLD *)new RawLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_RawLD, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_RawLD);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_RawLD(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    RawLD *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_RawLD TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "RawLD resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_RawLD) {
    RawLD *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_RawLD) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_RawLD. Expected %s", 1-argbase, SWIGTYPE_p_RawLD->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_RawLD_createModule) {
    RawLD *arg1 ;
    char *arg2 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_RawLD) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of RawLD_createModule. Expected %s", 1-argbase, SWIGTYPE_p_RawLD->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (unsigned char)(arg1)->createModule((char const *)arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


// property handler for class RawLD
static pval _wrap_propget_RawLD(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_RawLD(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_RawLD(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawLD
  {
    // chain to base class
    if (_propget_SWLD(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_RawLD(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_RawLD(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_RawLD(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawLD
  {
    // chain to base class
    if (_propset_SWLD(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_RawLD4) {
    char *arg1 ;
    char *arg2 = 0 ;
    char *arg3 = 0 ;
    SWDisplay *arg4 = 0 ;
    SWTextEncoding arg5 = ENC_UNKNOWN ;
    SWTextDirection arg6 = DIRECTION_LTR ;
    SWTextMarkup arg7 = FMT_UNKNOWN ;
    char *arg8 = 0 ;
    RawLD4 *result;
    zval **args[9];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(8-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        convert_to_string_ex(args[2-argbase]);
        arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
        
    }
    if(arg_count > 3) {
        if(SWIG_ConvertPtr(*args[3-argbase], (void **) &arg4, SWIGTYPE_p_SWDisplay) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_RawLD4. Expected %s", 4-argbase, SWIGTYPE_p_SWDisplay->name);
        }
        
    }
    if(arg_count > 4) {
        {
            SWTextEncoding * argp;
            if(SWIG_ConvertPtr(*args[4-argbase], (void **) &argp, SWIGTYPE_p_SWTextEncoding) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawLD4. Expected %s", 5-argbase, SWIGTYPE_p_SWTextEncoding->name);
            }
            arg5 = *argp;
        }
    }
    if(arg_count > 5) {
        {
            SWTextDirection * argp;
            if(SWIG_ConvertPtr(*args[5-argbase], (void **) &argp, SWIGTYPE_p_SWTextDirection) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawLD4. Expected %s", 6-argbase, SWIGTYPE_p_SWTextDirection->name);
            }
            arg6 = *argp;
        }
    }
    if(arg_count > 6) {
        {
            SWTextMarkup * argp;
            if(SWIG_ConvertPtr(*args[6-argbase], (void **) &argp, SWIGTYPE_p_SWTextMarkup) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_RawLD4. Expected %s", 7-argbase, SWIGTYPE_p_SWTextMarkup->name);
            }
            arg7 = *argp;
        }
    }
    if(arg_count > 7) {
        convert_to_string_ex(args[7-argbase]);
        arg8 = (char *) Z_STRVAL_PP(args[7-argbase]);
        
    }
    result = (RawLD4 *)new RawLD4((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,(char const *)arg8);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_RawLD4, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_RawLD4);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_RawLD4(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    RawLD4 *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_RawLD4 TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "RawLD4 resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_RawLD4) {
    RawLD4 *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_RawLD4) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_RawLD4. Expected %s", 1-argbase, SWIGTYPE_p_RawLD4->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_RawLD4_createModule) {
    RawLD4 *arg1 ;
    char *arg2 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_RawLD4) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of RawLD4_createModule. Expected %s", 1-argbase, SWIGTYPE_p_RawLD4->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (unsigned char)(arg1)->createModule((char const *)arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


// property handler for class RawLD4
static pval _wrap_propget_RawLD4(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_RawLD4(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_RawLD4(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawLD4
  {
    // chain to base class
    if (_propget_SWLD(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_RawLD4(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_RawLD4(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_RawLD4(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass RawLD4
  {
    // chain to base class
    if (_propset_SWLD(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_zLD) {
    char *arg1 ;
    char *arg2 = 0 ;
    char *arg3 = 0 ;
    long arg4 = 200 ;
    SWCompress *arg5 = 0 ;
    SWDisplay *arg6 = 0 ;
    SWTextEncoding arg7 = ENC_UNKNOWN ;
    SWTextDirection arg8 = DIRECTION_LTR ;
    SWTextMarkup arg9 = FMT_UNKNOWN ;
    char *arg10 = 0 ;
    zLD *result;
    zval **args[11];
    int argbase=0 ;
    int arg_count;
    
    // NATIVE Constructor
    int self_constructor=1;
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(10-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    convert_to_string_ex(((0<argbase)?(&this_ptr):(args[0-argbase])));
    arg1 = (char *) Z_STRVAL_PP(((0<argbase)?(&this_ptr):(args[0-argbase])));
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        convert_to_string_ex(args[2-argbase]);
        arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
        
    }
    if(arg_count > 3) {
        convert_to_long_ex(args[3-argbase]);
        arg4 = (long) Z_LVAL_PP(args[3-argbase]);
        
    }
    if(arg_count > 4) {
        if(SWIG_ConvertPtr(*args[4-argbase], (void **) &arg5, SWIGTYPE_p_SWCompress) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_zLD. Expected %s", 5-argbase, SWIGTYPE_p_SWCompress->name);
        }
        
    }
    if(arg_count > 5) {
        if(SWIG_ConvertPtr(*args[5-argbase], (void **) &arg6, SWIGTYPE_p_SWDisplay) < 0) {
            zend_error(E_ERROR, "Type error in argument %d of new_zLD. Expected %s", 6-argbase, SWIGTYPE_p_SWDisplay->name);
        }
        
    }
    if(arg_count > 6) {
        {
            SWTextEncoding * argp;
            if(SWIG_ConvertPtr(*args[6-argbase], (void **) &argp, SWIGTYPE_p_SWTextEncoding) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_zLD. Expected %s", 7-argbase, SWIGTYPE_p_SWTextEncoding->name);
            }
            arg7 = *argp;
        }
    }
    if(arg_count > 7) {
        {
            SWTextDirection * argp;
            if(SWIG_ConvertPtr(*args[7-argbase], (void **) &argp, SWIGTYPE_p_SWTextDirection) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_zLD. Expected %s", 8-argbase, SWIGTYPE_p_SWTextDirection->name);
            }
            arg8 = *argp;
        }
    }
    if(arg_count > 8) {
        {
            SWTextMarkup * argp;
            if(SWIG_ConvertPtr(*args[8-argbase], (void **) &argp, SWIGTYPE_p_SWTextMarkup) < 0) {
                zend_error(E_ERROR, "Type error in argument %d of new_zLD. Expected %s", 9-argbase, SWIGTYPE_p_SWTextMarkup->name);
            }
            arg9 = *argp;
        }
    }
    if(arg_count > 9) {
        convert_to_string_ex(args[9-argbase]);
        arg10 = (char *) Z_STRVAL_PP(args[9-argbase]);
        
    }
    result = (zLD *)new zLD((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4,arg5,arg6,arg7,arg8,arg9,(char const *)arg10);
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_zLD, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_zLD);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_zLD(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    zLD *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_zLD TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "zLD resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_zLD) {
    zLD *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_zLD) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_zLD. Expected %s", 1-argbase, SWIGTYPE_p_zLD->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_zLD_createModule) {
    zLD *arg1 ;
    char *arg2 ;
    unsigned char result;
    zval **args[3];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 2) || (zend_get_parameters_array_ex(2-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_zLD) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of zLD_createModule. Expected %s", 1-argbase, SWIGTYPE_p_zLD->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    result = (unsigned char)(arg1)->createModule((char const *)arg2);
    
    
    ZVAL_LONG(return_value,result);
    
}


// property handler for class zLD
static pval _wrap_propget_zLD(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_zLD(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_zLD(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass zLD
  {
    // chain to base class
    if (_propget_SWLD(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_zLD(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_zLD(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_zLD(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass zLD
  {
    // chain to base class
    if (_propset_SWLD(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_SWCompress) {
    SWCompress *result;
    zval **args[1];
    int argbase=0 ;
    
    // NATIVE Constructor
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (SWCompress *)new SWCompress();
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_SWCompress, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_SWCompress);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_SWCompress(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    SWCompress *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_SWCompress TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "SWCompress resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_SWCompress) {
    SWCompress *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_SWCompress. Expected %s", 1-argbase, SWIGTYPE_p_SWCompress->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_SWCompress_Buf) {
    SWCompress *arg1 ;
    char *arg2 = 0 ;
    unsigned long *arg3 = 0 ;
    char *result;
    unsigned long intr3 ;
    int force3 ;
    zval **args[4];
    int argbase=0 ;
    int arg_count;
    zval ** _saved[1] ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(1-argbase) || arg_count>(3-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWCompress_Buf. Expected %s", 1-argbase, SWIGTYPE_p_SWCompress->name);
    }
    
    if(arg_count > 1) {
        convert_to_string_ex(args[1-argbase]);
        arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
        
    }
    if(arg_count > 2) {
        if(SWIG_ConvertPtr(*args[2-argbase], (void **) &arg3, SWIGTYPE_p_unsigned_long) < 0) {
            // So... we didn't get a ref or ptr, but can it be 
            // reasonably co-erced into what we were 
            // looking for a ref of or ptr to?
            if ((*args[2-argbase])->type==IS_STRING ||
            (*args[2-argbase])->type==IS_LONG ||
            (*args[2-argbase])->type==IS_DOUBLE) {
                convert_to_long_ex(args[2-argbase]);
                intr3 = (unsigned long) (*args[2-argbase])->value.lval;
                arg3 = &intr3;
                // have to passback arg$arg too
                force3=1;
            }else {
                // wasn't a pre/ref/thing, OR anything like an int thing
                force3=0;
                zend_error(E_ERROR, "Type error in argument %d of SWCompress_Buf. Expected %s or at least something looking vaguely like a number hopefully passed by reference", 3-argbase, SWIGTYPE_p_unsigned_long->name);
            }
        }else force3=0;
        
    }
    _saved[0] = args[2-argbase];
    result = (char *)(arg1)->Buf((char const *)arg2,arg3);
    
    
    ZVAL_STRING(return_value,result, 1);
    
    
    if (force3) {
        // pass back arg3 through params (_saved[0]) if we can
        if(! PZVAL_IS_REF(*_saved[0])) {
            zend_error(E_WARNING, "Parameter %d of SWCompress_Buf wasn't passed by reference",3-argbase);
        }else {
            ZVAL_LONG(*_saved[0],intr3);
        }
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_SWCompress_zBuf) {
    SWCompress *arg1 ;
    unsigned long *arg2 ;
    char *arg3 = 0 ;
    char *result;
    unsigned long intr2 ;
    int force2 ;
    zval **args[4];
    int argbase=0 ;
    int arg_count;
    zval ** _saved[1] ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    arg_count = ZEND_NUM_ARGS();
    if(arg_count<(2-argbase) || arg_count>(3-argbase))
    WRONG_PARAM_COUNT;
    
    if(zend_get_parameters_array_ex(arg_count-argbase,args)!=SUCCESS)
    WRONG_PARAM_COUNT;
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWCompress_zBuf. Expected %s", 1-argbase, SWIGTYPE_p_SWCompress->name);
    }
    
    
    if(SWIG_ConvertPtr(*args[1-argbase], (void **) &arg2, SWIGTYPE_p_unsigned_long) < 0) {
        // So... we didn't get a ref or ptr, but can it be 
        // reasonably co-erced into what we were 
        // looking for a ref of or ptr to?
        if ((*args[1-argbase])->type==IS_STRING ||
        (*args[1-argbase])->type==IS_LONG ||
        (*args[1-argbase])->type==IS_DOUBLE) {
            convert_to_long_ex(args[1-argbase]);
            intr2 = (unsigned long) (*args[1-argbase])->value.lval;
            arg2 = &intr2;
            // have to passback arg$arg too
            force2=1;
        }else {
            // wasn't a pre/ref/thing, OR anything like an int thing
            force2=0;
            zend_error(E_ERROR, "Type error in argument %d of SWCompress_zBuf. Expected %s or at least something looking vaguely like a number hopefully passed by reference", 2-argbase, SWIGTYPE_p_unsigned_long->name);
        }
    }else force2=0;
    
    if(arg_count > 2) {
        convert_to_string_ex(args[2-argbase]);
        arg3 = (char *) Z_STRVAL_PP(args[2-argbase]);
        
    }
    _saved[0] = args[1-argbase];
    result = (char *)(arg1)->zBuf(arg2,arg3);
    
    
    ZVAL_STRING(return_value,result, 1);
    
    
    if (force2) {
        // pass back arg2 through params (_saved[0]) if we can
        if(! PZVAL_IS_REF(*_saved[0])) {
            zend_error(E_WARNING, "Parameter %d of SWCompress_zBuf wasn't passed by reference",2-argbase);
        }else {
            ZVAL_LONG(*_saved[0],intr2);
        }
    }
    
}


ZEND_NAMED_FUNCTION(_wrap_SWCompress_GetChars) {
    SWCompress *arg1 ;
    char *arg2 ;
    unsigned long arg3 ;
    unsigned long result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWCompress_GetChars. Expected %s", 1-argbase, SWIGTYPE_p_SWCompress->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_long_ex(args[2-argbase]);
    arg3 = (unsigned long) Z_LVAL_PP(args[2-argbase]);
    
    result = (unsigned long)(arg1)->GetChars(arg2,arg3);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWCompress_SendChars) {
    SWCompress *arg1 ;
    char *arg2 ;
    unsigned long arg3 ;
    unsigned long result;
    zval **args[4];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 3) || (zend_get_parameters_array_ex(3-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWCompress_SendChars. Expected %s", 1-argbase, SWIGTYPE_p_SWCompress->name);
    }
    
    
    convert_to_string_ex(args[1-argbase]);
    arg2 = (char *) Z_STRVAL_PP(args[1-argbase]);
    
    
    convert_to_long_ex(args[2-argbase]);
    arg3 = (unsigned long) Z_LVAL_PP(args[2-argbase]);
    
    result = (unsigned long)(arg1)->SendChars(arg2,arg3);
    
    
    ZVAL_LONG(return_value,result);
    
}


ZEND_NAMED_FUNCTION(_wrap_SWCompress_Encode) {
    SWCompress *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWCompress_Encode. Expected %s", 1-argbase, SWIGTYPE_p_SWCompress->name);
    }
    
    (arg1)->Encode();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_SWCompress_Decode) {
    SWCompress *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_SWCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of SWCompress_Decode. Expected %s", 1-argbase, SWIGTYPE_p_SWCompress->name);
    }
    
    (arg1)->Decode();
    
    
}


// property handler for class SWCompress
static pval _wrap_propget_SWCompress(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_SWCompress(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_SWCompress(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

static int _wrap_propset_SWCompress(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_SWCompress(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_SWCompress(zend_property_reference *property_reference, pval *value) {
  /* get the property name */
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  char *propname=Z_STRVAL_P(&(property->element));
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_LZSSCompress) {
    LZSSCompress *result;
    zval **args[1];
    int argbase=0 ;
    
    // NATIVE Constructor
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (LZSSCompress *)new LZSSCompress();
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_LZSSCompress, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_LZSSCompress);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_LZSSCompress(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    LZSSCompress *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_LZSSCompress TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "LZSSCompress resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_LZSSCompress) {
    LZSSCompress *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LZSSCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_LZSSCompress. Expected %s", 1-argbase, SWIGTYPE_p_LZSSCompress->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_LZSSCompress_Encode) {
    LZSSCompress *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LZSSCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of LZSSCompress_Encode. Expected %s", 1-argbase, SWIGTYPE_p_LZSSCompress->name);
    }
    
    (arg1)->Encode();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_LZSSCompress_Decode) {
    LZSSCompress *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_LZSSCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of LZSSCompress_Decode. Expected %s", 1-argbase, SWIGTYPE_p_LZSSCompress->name);
    }
    
    (arg1)->Decode();
    
    
}


// property handler for class LZSSCompress
static pval _wrap_propget_LZSSCompress(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_LZSSCompress(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_LZSSCompress(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass LZSSCompress
  {
    // chain to base class
    if (_propget_SWCompress(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_LZSSCompress(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_LZSSCompress(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_LZSSCompress(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass LZSSCompress
  {
    // chain to base class
    if (_propset_SWCompress(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

ZEND_NAMED_FUNCTION(_wrap_new_ZipCompress) {
    ZipCompress *result;
    zval **args[1];
    int argbase=0 ;
    
    // NATIVE Constructor
    int self_constructor=1;
    if(((ZEND_NUM_ARGS() + argbase )!= 0) || (zend_get_parameters_array_ex(0-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    result = (ZipCompress *)new ZipCompress();
    
    
    SWIG_SetPointerZval(return_value, (void *)result, SWIGTYPE_p_ZipCompress, 1);
    
    // Wrap this return value
    if (this_ptr) {
        // NATIVE Constructor, use this_ptr
        zval *_cPtr; MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        add_property_zval(this_ptr,"_cPtr",_cPtr);
    }else if (! this_ptr) {
        // ALTERNATIVE Constructor, make an object wrapper
        zval *obj, *_cPtr;
        MAKE_STD_ZVAL(obj);
        MAKE_STD_ZVAL(_cPtr);
        *_cPtr = *return_value;
        INIT_ZVAL(*return_value);
        object_init_ex(obj,ptr_ce_swig_ZipCompress);
        add_property_zval(obj,"_cPtr",_cPtr);
        *return_value=*obj;
    }
}


// This function is designed to be called by the zend list destructors to typecast and do the actual destruction
void __wrap_delete_ZipCompress(zend_rsrc_list_entry *rsrc, const char *type_name TSRMLS_DC) {
    swig_object_wrapper *value=(swig_object_wrapper *) rsrc->ptr ;
    void *ptr=value->ptr ;
    int newobject=value->newobject ;
    ZipCompress *arg1 ;
    
    efree(value);
    if (! newobject) return; // can't delete it!
    SWIG_ZTS_ConvertResourceData(ptr,rsrc->type,type_name,(void **) &arg1,SWIGTYPE_p_ZipCompress TSRMLS_CC);
    if (! arg1) zend_error(E_ERROR, "ZipCompress resource already free'd");
    delete arg1;
    
}


ZEND_NAMED_FUNCTION(_wrap_delete_ZipCompress) {
    ZipCompress *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ZipCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of delete_ZipCompress. Expected %s", 1-argbase, SWIGTYPE_p_ZipCompress->name);
    }
    
    //if ((*args[0])->type==IS_RESOURCE) {
    //  // Get zend list destructor to free it
    //  zend_list_delete(Z_LVAL_PP(args[0]));
    //} else {
    delete arg1;
    
    //}
    
}


ZEND_NAMED_FUNCTION(_wrap_ZipCompress_Encode) {
    ZipCompress *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ZipCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ZipCompress_Encode. Expected %s", 1-argbase, SWIGTYPE_p_ZipCompress->name);
    }
    
    (arg1)->Encode();
    
    
}


ZEND_NAMED_FUNCTION(_wrap_ZipCompress_Decode) {
    ZipCompress *arg1 ;
    zval **args[2];
    int argbase=0 ;
    
    if (this_ptr && this_ptr->type==IS_OBJECT) {
        // fake this_ptr as first arg (till we can work out how to do it better
        argbase++;
    }
    if(((ZEND_NUM_ARGS() + argbase )!= 1) || (zend_get_parameters_array_ex(1-argbase, args)!= SUCCESS)) {
        WRONG_PARAM_COUNT;
    }
    
    
    if(SWIG_ConvertPtr(*((0<argbase)?(&this_ptr):(args[0-argbase])), (void **) &arg1, SWIGTYPE_p_ZipCompress) < 0) {
        zend_error(E_ERROR, "Type error in argument %d of ZipCompress_Decode. Expected %s", 1-argbase, SWIGTYPE_p_ZipCompress->name);
    }
    
    (arg1)->Decode();
    
    
}


// property handler for class ZipCompress
static pval _wrap_propget_ZipCompress(zend_property_reference *property_reference) {
  pval result;
  pval **_result;
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  result.type = IS_NULL;
  if (_propget_ZipCompress(property_reference, &result)==SUCCESS) return result;
  //return it ourselves
  if (zend_hash_find(Z_OBJPROP_P(property_reference->object),Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),(void**)&_result)==SUCCESS) return **_result;
  result.type = IS_NULL;
  return result;
}
static int _propget_ZipCompress(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass ZipCompress
  {
    // chain to base class
    if (_propget_SWCompress(property_reference,  value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

static int _wrap_propset_ZipCompress(zend_property_reference *property_reference, pval *value) { 
  zend_llist_element *element = property_reference->elements_list->head;
  zend_overloaded_element *property=(zend_overloaded_element *)element->data;
  if (_propset_ZipCompress(property_reference, value)==SUCCESS) return SUCCESS;
  //set it ourselves as we are actual class
  return add_property_zval_ex(property_reference->object,Z_STRVAL_P(&(property->element)),Z_STRLEN_P(&(property->element)),value);
}
static int _propset_ZipCompress(zend_property_reference *property_reference, pval *value) {
  // No extra properties for subclass ZipCompress
  {
    // chain to base class
    if (_propset_SWCompress(property_reference, value)==SUCCESS) return SUCCESS;
  }
  return FAILURE;
}

//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWLocale) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWMgr) {
// has destructor: __wrap_delete_SWMgr
__wrap_delete_SWMgr(rsrc, SWIGTYPE_p_SWMgr->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWCom) {
//bah! No destructor for this wrapped class!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_RawLD4) {
// has destructor: __wrap_delete_RawLD4
__wrap_delete_RawLD4(rsrc, SWIGTYPE_p_RawLD4->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_ListKey) {
// has destructor: __wrap_delete_ListKey
__wrap_delete_ListKey(rsrc, SWIGTYPE_p_ListKey->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWKey) {
// has destructor: __wrap_delete_SWKey
__wrap_delete_SWKey(rsrc, SWIGTYPE_p_SWKey->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_ConfigEntMap) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_p_char) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_RawLD) {
// has destructor: __wrap_delete_RawLD
__wrap_delete_RawLD(rsrc, SWIGTYPE_p_RawLD->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_TreeKey) {
//bah! No destructor for this wrapped class!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_bool) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_void) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWFilterMgr) {
//bah! No destructor for this wrapped class!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWLD) {
// has destructor: __wrap_delete_SWLD
__wrap_delete_SWLD(rsrc, SWIGTYPE_p_SWLD->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWTextDirection) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_RawText) {
// has destructor: __wrap_delete_RawText
__wrap_delete_RawText(rsrc, SWIGTYPE_p_RawText->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_f_char_p_void__void) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_VerseKey) {
// has destructor: __wrap_delete_VerseKey
__wrap_delete_VerseKey(rsrc, SWIGTYPE_p_VerseKey->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_ModMap) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_string) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SectionMap) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWDisplay) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_AttributeTypeList) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWText) {
// has destructor: __wrap_delete_SWText
__wrap_delete_SWText(rsrc, SWIGTYPE_p_SWText->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWCompress) {
// has destructor: __wrap_delete_SWCompress
__wrap_delete_SWCompress(rsrc, SWIGTYPE_p_SWCompress->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LZSSCompress) {
// has destructor: __wrap_delete_LZSSCompress
__wrap_delete_LZSSCompress(rsrc, SWIGTYPE_p_LZSSCompress->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_ZipCompress) {
// has destructor: __wrap_delete_ZipCompress
__wrap_delete_ZipCompress(rsrc, SWIGTYPE_p_ZipCompress->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SW_POSITION) {
// has destructor: __wrap_delete_SW_POSITION
__wrap_delete_SW_POSITION(rsrc, SWIGTYPE_p_SW_POSITION->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWModule) {
// has destructor: __wrap_delete_SWModule
__wrap_delete_SWModule(rsrc, SWIGTYPE_p_SWModule->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_zLD) {
// has destructor: __wrap_delete_zLD
__wrap_delete_zLD(rsrc, SWIGTYPE_p_zLD->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWGenBook) {
//bah! No destructor for this wrapped class!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_RawGenBook) {
// has destructor: __wrap_delete_RawGenBook
__wrap_delete_RawGenBook(rsrc, SWIGTYPE_p_RawGenBook->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWConfig) {
// has destructor: __wrap_delete_SWConfig
__wrap_delete_SWConfig(rsrc, SWIGTYPE_p_SWConfig->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_LocaleMgr) {
// has destructor: __wrap_delete_LocaleMgr
__wrap_delete_LocaleMgr(rsrc, SWIGTYPE_p_LocaleMgr->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_int) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWTextMarkup) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_OptionsList) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_listTstring_t) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_zText) {
// has destructor: __wrap_delete_zText
__wrap_delete_zText(rsrc, SWIGTYPE_p_zText->name TSRMLS_CC);
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_SWTextEncoding) {
//bah! No destructor for this simple type!!
}
//NEW Destructor style
static ZEND_RSRC_DTOR_FUNC(_wrap_destroy_p_unsigned_long) {
//bah! No destructor for this simple type!!
}




/* end wrapper section */
/* init section */
#ifdef COMPILE_DL_SWORD
#ifdef __cplusplus
extern "C" {
#endif
ZEND_GET_MODULE(Sword)
#ifdef __cplusplus
}
#endif

#endif

PHP_MSHUTDOWN_FUNCTION(Sword)
{
    return SUCCESS;
}
PHP_MINIT_FUNCTION(Sword)
{
    int i;
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
/* oinit subsection */
// Define class SWConfig
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWConfig,"swconfig",SWConfig_functions,NULL,_wrap_propget_SWConfig,_wrap_propset_SWConfig);
if (! (ptr_ce_swig_SWConfig=zend_register_internal_class_ex(&ce_swig_SWConfig,NULL,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWConfig");

// Define class SWMgr
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWMgr,"swmgr",SWMgr_functions,NULL,_wrap_propget_SWMgr,_wrap_propset_SWMgr);
if (! (ptr_ce_swig_SWMgr=zend_register_internal_class_ex(&ce_swig_SWMgr,NULL,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWMgr");

// Define class SWModule
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWModule,"swmodule",SWModule_functions,NULL,_wrap_propget_SWModule,_wrap_propset_SWModule);
if (! (ptr_ce_swig_SWModule=zend_register_internal_class_ex(&ce_swig_SWModule,NULL,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWModule");

// Define class SW_POSITION
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SW_POSITION,"sw_position",SW_POSITION_functions,NULL,_wrap_propget_SW_POSITION,_wrap_propset_SW_POSITION);
if (! (ptr_ce_swig_SW_POSITION=zend_register_internal_class_ex(&ce_swig_SW_POSITION,NULL,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SW_POSITION");

// Define class SWKey
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWKey,"swkey",SWKey_functions,NULL,_wrap_propget_SWKey,_wrap_propset_SWKey);
if (! (ptr_ce_swig_SWKey=zend_register_internal_class_ex(&ce_swig_SWKey,NULL,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWKey");

// Define class VerseKey
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_VerseKey,"versekey",VerseKey_functions,NULL,_wrap_propget_VerseKey,_wrap_propset_VerseKey);
if (! (ptr_ce_swig_VerseKey=zend_register_internal_class_ex(&ce_swig_VerseKey,&ce_swig_SWKey,NULL))) zend_error(E_ERROR,"Error registering wrapper for class VerseKey");

// Define class ListKey
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_ListKey,"listkey",ListKey_functions,NULL,_wrap_propget_ListKey,_wrap_propset_ListKey);
if (! (ptr_ce_swig_ListKey=zend_register_internal_class_ex(&ce_swig_ListKey,&ce_swig_SWKey,NULL))) zend_error(E_ERROR,"Error registering wrapper for class ListKey");

// Define class TreeKey
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_TreeKey,"treekey",TreeKey_functions,NULL,_wrap_propget_TreeKey,_wrap_propset_TreeKey);
if (! (ptr_ce_swig_TreeKey=zend_register_internal_class_ex(&ce_swig_TreeKey,&ce_swig_SWKey,NULL))) zend_error(E_ERROR,"Error registering wrapper for class TreeKey");

// Define class TreeKeyIdx
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_TreeKeyIdx,"treekeyidx",TreeKeyIdx_functions,NULL,_wrap_propget_TreeKeyIdx,_wrap_propset_TreeKeyIdx);
if (! (ptr_ce_swig_TreeKeyIdx=zend_register_internal_class_ex(&ce_swig_TreeKeyIdx,&ce_swig_TreeKey,NULL))) zend_error(E_ERROR,"Error registering wrapper for class TreeKeyIdx");

// Define class LocaleMgr
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LocaleMgr,"localemgr",LocaleMgr_functions,NULL,_wrap_propget_LocaleMgr,_wrap_propset_LocaleMgr);
if (! (ptr_ce_swig_LocaleMgr=zend_register_internal_class_ex(&ce_swig_LocaleMgr,NULL,NULL))) zend_error(E_ERROR,"Error registering wrapper for class LocaleMgr");

// Define class SWFilterMgr
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWFilterMgr,"swfiltermgr",SWFilterMgr_functions,NULL,_wrap_propget_SWFilterMgr,_wrap_propset_SWFilterMgr);
if (! (ptr_ce_swig_SWFilterMgr=zend_register_internal_class_ex(&ce_swig_SWFilterMgr,NULL,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWFilterMgr");

// Define class SWText
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWText,"swtext",SWText_functions,NULL,_wrap_propget_SWText,_wrap_propset_SWText);
if (! (ptr_ce_swig_SWText=zend_register_internal_class_ex(&ce_swig_SWText,&ce_swig_SWModule,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWText");

// Define class RawText
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_RawText,"rawtext",RawText_functions,NULL,_wrap_propget_RawText,_wrap_propset_RawText);
if (! (ptr_ce_swig_RawText=zend_register_internal_class_ex(&ce_swig_RawText,&ce_swig_SWText,NULL))) zend_error(E_ERROR,"Error registering wrapper for class RawText");

// Define class zText
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_zText,"ztext",zText_functions,NULL,_wrap_propget_zText,_wrap_propset_zText);
if (! (ptr_ce_swig_zText=zend_register_internal_class_ex(&ce_swig_zText,&ce_swig_SWText,NULL))) zend_error(E_ERROR,"Error registering wrapper for class zText");

// Define class SWCom
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWCom,"swcom",SWCom_functions,NULL,_wrap_propget_SWCom,_wrap_propset_SWCom);
if (! (ptr_ce_swig_SWCom=zend_register_internal_class_ex(&ce_swig_SWCom,&ce_swig_SWModule,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWCom");

// Define class RawCom
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_RawCom,"rawcom",RawCom_functions,NULL,_wrap_propget_RawCom,_wrap_propset_RawCom);
if (! (ptr_ce_swig_RawCom=zend_register_internal_class_ex(&ce_swig_RawCom,&ce_swig_SWCom,NULL))) zend_error(E_ERROR,"Error registering wrapper for class RawCom");

// Define class zCom
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_zCom,"zcom",zCom_functions,NULL,_wrap_propget_zCom,_wrap_propset_zCom);
if (! (ptr_ce_swig_zCom=zend_register_internal_class_ex(&ce_swig_zCom,&ce_swig_SWCom,NULL))) zend_error(E_ERROR,"Error registering wrapper for class zCom");

// Define class SWGenBook
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWGenBook,"swgenbook",SWGenBook_functions,NULL,_wrap_propget_SWGenBook,_wrap_propset_SWGenBook);
if (! (ptr_ce_swig_SWGenBook=zend_register_internal_class_ex(&ce_swig_SWGenBook,&ce_swig_SWModule,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWGenBook");

// Define class RawGenBook
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_RawGenBook,"rawgenbook",RawGenBook_functions,NULL,_wrap_propget_RawGenBook,_wrap_propset_RawGenBook);
if (! (ptr_ce_swig_RawGenBook=zend_register_internal_class_ex(&ce_swig_RawGenBook,&ce_swig_SWGenBook,NULL))) zend_error(E_ERROR,"Error registering wrapper for class RawGenBook");

// Define class SWLD
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWLD,"swld",SWLD_functions,NULL,_wrap_propget_SWLD,_wrap_propset_SWLD);
if (! (ptr_ce_swig_SWLD=zend_register_internal_class_ex(&ce_swig_SWLD,&ce_swig_SWModule,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWLD");

// Define class RawLD
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_RawLD,"rawld",RawLD_functions,NULL,_wrap_propget_RawLD,_wrap_propset_RawLD);
if (! (ptr_ce_swig_RawLD=zend_register_internal_class_ex(&ce_swig_RawLD,&ce_swig_SWLD,NULL))) zend_error(E_ERROR,"Error registering wrapper for class RawLD");

// Define class RawLD4
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_RawLD4,"rawld4",RawLD4_functions,NULL,_wrap_propget_RawLD4,_wrap_propset_RawLD4);
if (! (ptr_ce_swig_RawLD4=zend_register_internal_class_ex(&ce_swig_RawLD4,&ce_swig_SWLD,NULL))) zend_error(E_ERROR,"Error registering wrapper for class RawLD4");

// Define class zLD
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_zLD,"zld",zLD_functions,NULL,_wrap_propget_zLD,_wrap_propset_zLD);
if (! (ptr_ce_swig_zLD=zend_register_internal_class_ex(&ce_swig_zLD,&ce_swig_SWLD,NULL))) zend_error(E_ERROR,"Error registering wrapper for class zLD");

// Define class SWCompress
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_SWCompress,"swcompress",SWCompress_functions,NULL,_wrap_propget_SWCompress,_wrap_propset_SWCompress);
if (! (ptr_ce_swig_SWCompress=zend_register_internal_class_ex(&ce_swig_SWCompress,NULL,NULL))) zend_error(E_ERROR,"Error registering wrapper for class SWCompress");

// Define class LZSSCompress
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_LZSSCompress,"lzsscompress",LZSSCompress_functions,NULL,_wrap_propget_LZSSCompress,_wrap_propset_LZSSCompress);
if (! (ptr_ce_swig_LZSSCompress=zend_register_internal_class_ex(&ce_swig_LZSSCompress,&ce_swig_SWCompress,NULL))) zend_error(E_ERROR,"Error registering wrapper for class LZSSCompress");

// Define class ZipCompress
INIT_OVERLOADED_CLASS_ENTRY(ce_swig_ZipCompress,"zipcompress",ZipCompress_functions,NULL,_wrap_propget_ZipCompress,_wrap_propset_ZipCompress);
if (! (ptr_ce_swig_ZipCompress=zend_register_internal_class_ex(&ce_swig_ZipCompress,&ce_swig_SWCompress,NULL))) zend_error(E_ERROR,"Error registering wrapper for class ZipCompress");


// Register resource destructors for pointer types
le_swig__p_SWLocale=zend_register_list_destructors_ex(_wrap_destroy_p_SWLocale,NULL,(char *)(SWIGTYPE_p_SWLocale->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWLocale,&le_swig__p_SWLocale);
le_swig__p_SWMgr=zend_register_list_destructors_ex(_wrap_destroy_p_SWMgr,NULL,(char *)(SWIGTYPE_p_SWMgr->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWMgr,&le_swig__p_SWMgr);
le_swig__p_SWCom=zend_register_list_destructors_ex(_wrap_destroy_p_SWCom,NULL,(char *)(SWIGTYPE_p_SWCom->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWCom,&le_swig__p_SWCom);
le_swig__p_RawLD4=zend_register_list_destructors_ex(_wrap_destroy_p_RawLD4,NULL,(char *)(SWIGTYPE_p_RawLD4->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_RawLD4,&le_swig__p_RawLD4);
le_swig__p_ListKey=zend_register_list_destructors_ex(_wrap_destroy_p_ListKey,NULL,(char *)(SWIGTYPE_p_ListKey->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_ListKey,&le_swig__p_ListKey);
le_swig__p_SWKey=zend_register_list_destructors_ex(_wrap_destroy_p_SWKey,NULL,(char *)(SWIGTYPE_p_SWKey->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWKey,&le_swig__p_SWKey);
le_swig__p_ConfigEntMap=zend_register_list_destructors_ex(_wrap_destroy_p_ConfigEntMap,NULL,(char *)(SWIGTYPE_p_ConfigEntMap->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_ConfigEntMap,&le_swig__p_ConfigEntMap);
le_swig__p_p_char=zend_register_list_destructors_ex(_wrap_destroy_p_p_char,NULL,(char *)(SWIGTYPE_p_p_char->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_p_char,&le_swig__p_p_char);
le_swig__p_RawLD=zend_register_list_destructors_ex(_wrap_destroy_p_RawLD,NULL,(char *)(SWIGTYPE_p_RawLD->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_RawLD,&le_swig__p_RawLD);
le_swig__p_TreeKey=zend_register_list_destructors_ex(_wrap_destroy_p_TreeKey,NULL,(char *)(SWIGTYPE_p_TreeKey->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_TreeKey,&le_swig__p_TreeKey);
le_swig__p_bool=zend_register_list_destructors_ex(_wrap_destroy_p_bool,NULL,(char *)(SWIGTYPE_p_bool->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_bool,&le_swig__p_bool);
le_swig__p_void=zend_register_list_destructors_ex(_wrap_destroy_p_void,NULL,(char *)(SWIGTYPE_p_void->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_void,&le_swig__p_void);
le_swig__p_SWFilterMgr=zend_register_list_destructors_ex(_wrap_destroy_p_SWFilterMgr,NULL,(char *)(SWIGTYPE_p_SWFilterMgr->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWFilterMgr,&le_swig__p_SWFilterMgr);
le_swig__p_SWLD=zend_register_list_destructors_ex(_wrap_destroy_p_SWLD,NULL,(char *)(SWIGTYPE_p_SWLD->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWLD,&le_swig__p_SWLD);
le_swig__p_SWTextDirection=zend_register_list_destructors_ex(_wrap_destroy_p_SWTextDirection,NULL,(char *)(SWIGTYPE_p_SWTextDirection->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWTextDirection,&le_swig__p_SWTextDirection);
le_swig__p_RawText=zend_register_list_destructors_ex(_wrap_destroy_p_RawText,NULL,(char *)(SWIGTYPE_p_RawText->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_RawText,&le_swig__p_RawText);
le_swig__p_f_char_p_void__void=zend_register_list_destructors_ex(_wrap_destroy_p_f_char_p_void__void,NULL,(char *)(SWIGTYPE_p_f_char_p_void__void->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_f_char_p_void__void,&le_swig__p_f_char_p_void__void);
le_swig__p_VerseKey=zend_register_list_destructors_ex(_wrap_destroy_p_VerseKey,NULL,(char *)(SWIGTYPE_p_VerseKey->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_VerseKey,&le_swig__p_VerseKey);
le_swig__p_ModMap=zend_register_list_destructors_ex(_wrap_destroy_p_ModMap,NULL,(char *)(SWIGTYPE_p_ModMap->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_ModMap,&le_swig__p_ModMap);
le_swig__p_string=zend_register_list_destructors_ex(_wrap_destroy_p_string,NULL,(char *)(SWIGTYPE_p_string->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_string,&le_swig__p_string);
le_swig__p_SectionMap=zend_register_list_destructors_ex(_wrap_destroy_p_SectionMap,NULL,(char *)(SWIGTYPE_p_SectionMap->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SectionMap,&le_swig__p_SectionMap);
le_swig__p_SWDisplay=zend_register_list_destructors_ex(_wrap_destroy_p_SWDisplay,NULL,(char *)(SWIGTYPE_p_SWDisplay->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWDisplay,&le_swig__p_SWDisplay);
le_swig__p_AttributeTypeList=zend_register_list_destructors_ex(_wrap_destroy_p_AttributeTypeList,NULL,(char *)(SWIGTYPE_p_AttributeTypeList->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_AttributeTypeList,&le_swig__p_AttributeTypeList);
le_swig__p_SWText=zend_register_list_destructors_ex(_wrap_destroy_p_SWText,NULL,(char *)(SWIGTYPE_p_SWText->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWText,&le_swig__p_SWText);
le_swig__p_SWCompress=zend_register_list_destructors_ex(_wrap_destroy_p_SWCompress,NULL,(char *)(SWIGTYPE_p_SWCompress->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWCompress,&le_swig__p_SWCompress);
le_swig__p_LZSSCompress=zend_register_list_destructors_ex(_wrap_destroy_p_LZSSCompress,NULL,(char *)(SWIGTYPE_p_LZSSCompress->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LZSSCompress,&le_swig__p_LZSSCompress);
le_swig__p_ZipCompress=zend_register_list_destructors_ex(_wrap_destroy_p_ZipCompress,NULL,(char *)(SWIGTYPE_p_ZipCompress->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_ZipCompress,&le_swig__p_ZipCompress);
le_swig__p_SW_POSITION=zend_register_list_destructors_ex(_wrap_destroy_p_SW_POSITION,NULL,(char *)(SWIGTYPE_p_SW_POSITION->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SW_POSITION,&le_swig__p_SW_POSITION);
le_swig__p_SWModule=zend_register_list_destructors_ex(_wrap_destroy_p_SWModule,NULL,(char *)(SWIGTYPE_p_SWModule->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWModule,&le_swig__p_SWModule);
le_swig__p_zLD=zend_register_list_destructors_ex(_wrap_destroy_p_zLD,NULL,(char *)(SWIGTYPE_p_zLD->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_zLD,&le_swig__p_zLD);
le_swig__p_SWGenBook=zend_register_list_destructors_ex(_wrap_destroy_p_SWGenBook,NULL,(char *)(SWIGTYPE_p_SWGenBook->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWGenBook,&le_swig__p_SWGenBook);
le_swig__p_RawGenBook=zend_register_list_destructors_ex(_wrap_destroy_p_RawGenBook,NULL,(char *)(SWIGTYPE_p_RawGenBook->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_RawGenBook,&le_swig__p_RawGenBook);
le_swig__p_SWConfig=zend_register_list_destructors_ex(_wrap_destroy_p_SWConfig,NULL,(char *)(SWIGTYPE_p_SWConfig->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWConfig,&le_swig__p_SWConfig);
le_swig__p_LocaleMgr=zend_register_list_destructors_ex(_wrap_destroy_p_LocaleMgr,NULL,(char *)(SWIGTYPE_p_LocaleMgr->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_LocaleMgr,&le_swig__p_LocaleMgr);
le_swig__p_int=zend_register_list_destructors_ex(_wrap_destroy_p_int,NULL,(char *)(SWIGTYPE_p_int->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_int,&le_swig__p_int);
le_swig__p_SWTextMarkup=zend_register_list_destructors_ex(_wrap_destroy_p_SWTextMarkup,NULL,(char *)(SWIGTYPE_p_SWTextMarkup->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWTextMarkup,&le_swig__p_SWTextMarkup);
le_swig__p_OptionsList=zend_register_list_destructors_ex(_wrap_destroy_p_OptionsList,NULL,(char *)(SWIGTYPE_p_OptionsList->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_OptionsList,&le_swig__p_OptionsList);
le_swig__p_listTstring_t=zend_register_list_destructors_ex(_wrap_destroy_p_listTstring_t,NULL,(char *)(SWIGTYPE_p_listTstring_t->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_listTstring_t,&le_swig__p_listTstring_t);
le_swig__p_zText=zend_register_list_destructors_ex(_wrap_destroy_p_zText,NULL,(char *)(SWIGTYPE_p_zText->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_zText,&le_swig__p_zText);
le_swig__p_SWTextEncoding=zend_register_list_destructors_ex(_wrap_destroy_p_SWTextEncoding,NULL,(char *)(SWIGTYPE_p_SWTextEncoding->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_SWTextEncoding,&le_swig__p_SWTextEncoding);
le_swig__p_unsigned_long=zend_register_list_destructors_ex(_wrap_destroy_p_unsigned_long,NULL,(char *)(SWIGTYPE_p_unsigned_long->name),module_number);
SWIG_TypeClientData(SWIGTYPE_p_unsigned_long,&le_swig__p_unsigned_long);
CG(active_class_entry) = NULL;
/* end oinit subsection */

    return SUCCESS;
}
PHP_RINIT_FUNCTION(Sword)
{
/* cinit subsection */
/* end cinit subsection */

/* vinit subsection */
/* end vinit subsection */

    return SUCCESS;
}
PHP_RSHUTDOWN_FUNCTION(Sword)
{
    return SUCCESS;
}
PHP_MINFO_FUNCTION(Sword)
{
}
/* end init section */
